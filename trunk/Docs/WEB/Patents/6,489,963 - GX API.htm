<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0167)http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=/netahtml/search-adv.htm&r=19&f=G&l=50&d=PTXT&p=1&S1=(Nintendo+AND+PowerPC)&OS=Nintendo+AND+PowerPC -->
<HTML><HEAD><TITLE>United States Patent: 6,489,963</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff><A name=top></A>
<CENTER><IMG 
alt="[US Patent &amp; Trademark Office, Patent Full Text and Image Database]" 
src="6,489,963 - GX API.files/patfthdr.gif"> <BR><!-- <IMG border=0 src=/netaicon/PTO/titlebar.gif><br> -->
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A href="http://www.uspto.gov/patft/index.html"><IMG 
      alt=[Home] src="6,489,963 - GX API.files/home.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
      alt="[Boolean Search]" src="6,489,963 - GX API.files/boolean.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG 
      alt="[Manual Search]" src="6,489,963 - GX API.files/manual.gif" border=0 
      valign="middle"></A> <A 
      href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG 
      alt="[Number Search]" src="6,489,963 - GX API.files/number.gif" border=0 
      valign="middle"></A> <A 
      href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
      src="6,489,963 - GX API.files/help.gif" border=0 valign="middle"></A> 
  </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=19&amp;f=S&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;Query=Nintendo+AND+PowerPC"><IMG 
      alt=[HIT_LIST] src="6,489,963 - GX API.files/hitlist.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=18&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC"><IMG 
      alt=[PREV_DOC] src="6,489,963 - GX API.files/prevdoc.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=20&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC"><IMG 
      alt=[NEXT_DOC] src="6,489,963 - GX API.files/nextdoc.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=19&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC#bottom"><IMG 
      alt=[Bottom] src="6,489,963 - GX API.files/bottom.gif" border=0 
      valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%2Fnetahtml%2Fsearch-adv.htm%26r%3D19%26f%3DG%26l%3D50%26d%3DPTXT%26p%3D1%26S1%3D(Nintendo%252BAND%252BPowerPC)%26OS%3DNintendo%252BAND%252BPowerPC&amp;backLabel1=Back%20to%20Document%3A%206,489,963"><IMG 
      alt="[View Shopping Cart]" src="6,489,963 - GX API.files/cart.gif" 
      border=0 valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,489,963&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%2Fnetahtml%2Fsearch-adv.htm%26r%3D19%26f%3DG%26l%3D50%26d%3DPTXT%26p%3D1%26S1%3D(Nintendo%252BAND%252BPowerPC)%26OS%3DNintendo%252BAND%252BPowerPC&amp;backLabel1=Back%20to%20Document%3A%206,489,963"><IMG 
      alt="[Add to Shopping Cart]" src="6,489,963 - GX API.files/order.gif" 
      border=0 valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patimg2.uspto.gov/.piw?Docid=06489963&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%2Fnetahtml%2Fsearch-adv.htm%2526r%3D19%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526p%3D1%2526S1%3D(Nintendo%252BAND%252BPowerPC)%2526OS%3DNintendo%252BAND%252BPowerPC%2526RS%3D&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=78709CC1D7AA"><IMG 
      alt=[Image] src="6,489,963 - GX API.files/image.gif" border=0 
      valign="middle"></A> <!-- <A HREF="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=/netahtml/search-adv.htm&r=18&f=G&l=50&d=PTXT&p=1&S1=(Nintendo+AND+PowerPC)&OS=Nintendo+AND+PowerPC"><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A>
<BR><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ULL </FONT><FONT SIZE=4 COLOR="#CC3300">T</FONT><FONT SIZE=2 COLOR="#CC3300">EXT </FONT><FONT SIZE=4 COLOR="#CC3300">F</FONT><FONT SIZE=2 COLOR="#CC3300">ORMAT</FONT></STRONG> --></TD></TR></TBODY></TABLE></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%">&nbsp;</TD>
    <TD vAlign=bottom align=right width="50%"><FONT size=-1>( 
      <STRONG>19</STRONG></FONT> <FONT size=-2>of</FONT> <STRONG><FONT 
      size=-1>30</STRONG> )</FONT></TD></TR></TBODY></TABLE>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left width="50%"><B>United States Patent </B></TD>
    <TD align=right width="50%"><B>6,489,963 </B></TD></TR>
  <TR>
    <TD align=left width="50%"><B>Parikh , &nbsp; et al.</B> </TD>
    <TD align=right width="50%"><B>December 3, 2002 </B></TD></TR></TBODY></TABLE>
<HR>
<FONT size=+1>Application program interface for a graphics system 
</FONT><BR><BR>
<CENTER><B>Abstract</B></CENTER>
<P>An interface for a graphics system includes simple yet powerful constructs 
that are easy for an application programmer to use and learn. Features include a 
unique vertex representation allowing the graphics pipeline to retain vertex 
state information and to mix indexed and direct vertex values and attributes; a 
projection matrix value set command; a display list call object command; and an 
embedded frame buffer clear/set command. </P>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="10%">Inventors: </TD>
    <TD align=left width="90%"><B>Parikh; Vimal</B> (Santa Clara, CA); 
      <B>Moore; Robert</B> (Heathrow, FL); <B>Cheng; Howard</B> (Sammamish, WA) 
    </TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Assignee: </TD>
    <TD align=left width="90%"><B>Nintendo Co., Ltd.</B> (Kyoto, JP) </TD></TR>
  <TR>
    <TD vAlign=top noWrap align=left width="10%">Appl. No.: </TD>
    <TD align=left width="90%"><B>885949</B></TD></TR>
  <TR>
    <TD vAlign=top align=left width="10%">Filed: </TD>
    <TD align=left width="90%"><B>June 22, 2001</B></TD></TR></TBODY></TABLE>
<P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Current U.S. Class:</B></TD>
    <TD vAlign=top align=right width="60%"><B>345/522</B>; 345/581; 712/208; 
      719/328 </TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Intern'l Class: </B></TD>
    <TD vAlign=top align=right width="60%">G06T 015/00; G06F 015/16</TD></TR>
  <TR>
    <TD vAlign=top align=left width="40%"><B>Field of Search: </B></TD>
    <TD vAlign=top align=right width="60%">345/501,503,419,581,520,522,559 
      709/328 712/208 </TD></TR></TBODY></TABLE>
<HR>

<CENTER><B>References Cited <A 
href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-adv.htm&amp;r=0&amp;f=S&amp;l=50&amp;d=CR02&amp;Query=ref/6,489,963">[Referenced 
By]</A></B></CENTER>
<HR>

<CENTER><B>U.S. Patent Documents</B></CENTER>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4388620">4388620</A></TD>
    <TD width="25%">Jun., 1983</TD>
    <TD align=left width="25%">Sherman. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4425559">4425559</A></TD>
    <TD width="25%">Jan., 1984</TD>
    <TD align=left width="25%">Sherman. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4570233">4570233</A></TD>
    <TD width="25%">Feb., 1986</TD>
    <TD align=left width="25%">Yan et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4658247">4658247</A></TD>
    <TD width="25%">Apr., 1987</TD>
    <TD align=left width="25%">Charachorloo. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4725831">4725831</A></TD>
    <TD width="25%">Feb., 1988</TD>
    <TD align=left width="25%">Coleman. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4826295">4826295</A></TD>
    <TD width="25%">May., 1989</TD>
    <TD align=left width="25%">Hiroyuki. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4862392">4862392</A></TD>
    <TD width="25%">Aug., 1989</TD>
    <TD align=left width="25%">Steiner. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4866637">4866637</A></TD>
    <TD width="25%">Sep., 1989</TD>
    <TD align=left width="25%">Gonzalez-Lopez et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4901064">4901064</A></TD>
    <TD width="25%">Feb., 1990</TD>
    <TD align=left width="25%">Deering. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4914729">4914729</A></TD>
    <TD width="25%">Apr., 1990</TD>
    <TD align=left width="25%">Omori et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F4945500">4945500</A></TD>
    <TD width="25%">Jul., 1990</TD>
    <TD align=left width="25%">Deering. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5136664">5136664</A></TD>
    <TD width="25%">Aug., 1992</TD>
    <TD align=left width="25%">Bersack et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5170468">5170468</A></TD>
    <TD width="25%">Dec., 1992</TD>
    <TD align=left width="25%">Shah et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5392385">5392385</A></TD>
    <TD width="25%">Feb., 1995</TD>
    <TD align=left width="25%">Evangelisti et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5392393">5392393</A></TD>
    <TD width="25%">Feb., 1995</TD>
    <TD align=left width="25%">Deering. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5404445">5404445</A></TD>
    <TD width="25%">Apr., 1995</TD>
    <TD align=left width="25%">Matsumoto. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5421028">5421028</A></TD>
    <TD width="25%">May., 1995</TD>
    <TD align=left width="25%">Swanson. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5432900">5432900</A></TD>
    <TD width="25%">Jul., 1995</TD>
    <TD align=left width="25%">Rhodes et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5438663">5438663</A></TD>
    <TD width="25%">Aug., 1995</TD>
    <TD align=left width="25%">Matsumoto et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5457775">5457775</A></TD>
    <TD width="25%">Oct., 1995</TD>
    <TD align=left width="25%">Johnson, Jr. et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5504917">5504917</A></TD>
    <TD width="25%">Apr., 1996</TD>
    <TD align=left width="25%">Austin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5594854">5594854</A></TD>
    <TD width="25%">Jan., 1997</TD>
    <TD align=left width="25%">Baldwin et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5608424">5608424</A></TD>
    <TD width="25%">Mar., 1997</TD>
    <TD align=left width="25%">Takahashi et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5671401">5671401</A></TD>
    <TD width="25%">Sep., 1997</TD>
    <TD align=left width="25%">Harrell</TD>
    <TD align=right width="25%">345/441. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5687357">5687357</A></TD>
    <TD width="25%">Nov., 1997</TD>
    <TD align=left width="25%">Priem. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5701444">5701444</A></TD>
    <TD width="25%">Dec., 1997</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5721947">5721947</A></TD>
    <TD width="25%">Feb., 1998</TD>
    <TD align=left width="25%">Priem et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5727192">5727192</A></TD>
    <TD width="25%">Mar., 1998</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5751295">5751295</A></TD>
    <TD width="25%">May., 1998</TD>
    <TD align=left width="25%">Becklund et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5758182">5758182</A></TD>
    <TD width="25%">May., 1998</TD>
    <TD align=left width="25%">Rosenthal et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5764243">5764243</A></TD>
    <TD width="25%">Jun., 1998</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5768626">5768626</A></TD>
    <TD width="25%">Jun., 1998</TD>
    <TD align=left width="25%">Munson et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5768629">5768629</A></TD>
    <TD width="25%">Jun., 1998</TD>
    <TD align=left width="25%">Wise et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5774133">5774133</A></TD>
    <TD width="25%">Jun., 1998</TD>
    <TD align=left width="25%">Neave et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5777629">5777629</A></TD>
    <TD width="25%">Jul., 1998</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5798770">5798770</A></TD>
    <TD width="25%">Aug., 1998</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5801706">5801706</A></TD>
    <TD width="25%">Sep., 1998</TD>
    <TD align=left width="25%">Fujita et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5801716">5801716</A></TD>
    <TD width="25%">Sep., 1998</TD>
    <TD align=left width="25%">Silverbrook. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5805868">5805868</A></TD>
    <TD width="25%">Sep., 1998</TD>
    <TD align=left width="25%">Murphy. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5815166">5815166</A></TD>
    <TD width="25%">Sep., 1998</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5821949">5821949</A></TD>
    <TD width="25%">Oct., 1998</TD>
    <TD align=left width="25%">Deering. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5870587">5870587</A></TD>
    <TD width="25%">Feb., 1999</TD>
    <TD align=left width="25%">Danforth et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5874969">5874969</A></TD>
    <TD width="25%">Feb., 1999</TD>
    <TD align=left width="25%">Storm et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5917496">5917496</A></TD>
    <TD width="25%">Jun., 1999</TD>
    <TD align=left width="25%">Fujita et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5920326">5920326</A></TD>
    <TD width="25%">Jul., 1999</TD>
    <TD align=left width="25%">Rentschler et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5920876">5920876</A></TD>
    <TD width="25%">Jul., 1999</TD>
    <TD align=left width="25%">Ungar et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5936641">5936641</A></TD>
    <TD width="25%">Aug., 1999</TD>
    <TD align=left width="25%">Jain et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5940086">5940086</A></TD>
    <TD width="25%">Aug., 1999</TD>
    <TD align=left width="25%">Rentschler et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5949424">5949424</A></TD>
    <TD width="25%">Sep., 1999</TD>
    <TD align=left width="25%">Cabral et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5949440">5949440</A></TD>
    <TD width="25%">Sep., 1999</TD>
    <TD align=left width="25%">Krech, Jr. et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5966133">5966133</A></TD>
    <TD width="25%">Oct., 1999</TD>
    <TD align=left width="25%">Hoppe</TD>
    <TD align=right width="25%">345/420. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5969726">5969726</A></TD>
    <TD width="25%">Oct., 1999</TD>
    <TD align=left width="25%">Rentschler et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5995121">5995121</A></TD>
    <TD width="25%">Nov., 1999</TD>
    <TD align=left width="25%">Alcorn et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F5999196">5999196</A></TD>
    <TD width="25%">Dec., 1999</TD>
    <TD align=left width="25%">Storm et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6002409">6002409</A></TD>
    <TD width="25%">Dec., 1999</TD>
    <TD align=left width="25%">Harkin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6023738">6023738</A></TD>
    <TD width="25%">Feb., 2000</TD>
    <TD align=left width="25%">Priem et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6025853">6025853</A></TD>
    <TD width="25%">Feb., 2000</TD>
    <TD align=left width="25%">Baldwin. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6028611">6028611</A></TD>
    <TD width="25%">Feb., 2000</TD>
    <TD align=left width="25%">Anderson et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6031548">6031548</A></TD>
    <TD width="25%">Feb., 2000</TD>
    <TD align=left width="25%">Gueziec et al.</TD>
    <TD align=right width="25%">345/440. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6037949">6037949</A></TD>
    <TD width="25%">Mar., 2000</TD>
    <TD align=left width="25%">DeRose et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6052133">6052133</A></TD>
    <TD width="25%">Apr., 2000</TD>
    <TD align=left width="25%">Kang. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6057852">6057852</A></TD>
    <TD width="25%">May., 2000</TD>
    <TD align=left width="25%">Krech, Jr. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6057863">6057863</A></TD>
    <TD width="25%">May., 2000</TD>
    <TD align=left width="25%">Olarig. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6075540">6075540</A></TD>
    <TD width="25%">Jun., 2000</TD>
    <TD align=left width="25%">Hoppe</TD>
    <TD align=right width="25%">345/419. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6078331">6078331</A></TD>
    <TD width="25%">Jun., 2000</TD>
    <TD align=left width="25%">Pulli et al.</TD>
    <TD align=right width="25%">345/423. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6092124">6092124</A></TD>
    <TD width="25%">Jul., 2000</TD>
    <TD align=left width="25%">Priem et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6151602">6151602</A></TD>
    <TD width="25%">Nov., 2000</TD>
    <TD align=left width="25%">Hejlsberg et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6173367">6173367</A></TD>
    <TD width="25%">Jan., 2001</TD>
    <TD align=left width="25%">Aleksic et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6177944">6177944</A></TD>
    <TD width="25%">Jan., 2001</TD>
    <TD align=left width="25%">Fowler et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6181352">6181352</A></TD>
    <TD width="25%">Jan., 2001</TD>
    <TD align=left width="25%">Kirk et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6198488">6198488</A></TD>
    <TD width="25%">Mar., 2001</TD>
    <TD align=left width="25%">Lindholm et al.</TD>
    <TD align=right width="25%">345/418. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6222550">6222550</A></TD>
    <TD width="25%">Apr., 2001</TD>
    <TD align=left width="25%">Rosman et al.</TD>
    <TD align=right width="25%">345/419. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6222555">6222555</A></TD>
    <TD width="25%">Apr., 2001</TD>
    <TD align=left width="25%">Christofferson et al.</TD>
    <TD align=right width="25%">345/428. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6226012">6226012</A></TD>
    <TD width="25%">May., 2001</TD>
    <TD align=left width="25%">Priem et al. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6256041">6256041</A></TD>
    <TD width="25%">Jul., 2001</TD>
    <TD align=left width="25%">Deering</TD>
    <TD align=right width="25%">345/419. </TD></TR>
  <TR>
    <TD width="25%"><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect2=PTO1&amp;Sect2=HITOFF&amp;p=1&amp;u=%2Fnetahtml%2Fsearch-bool.html&amp;r=1&amp;f=G&amp;l=50&amp;d=PALL&amp;RefSrch=yes&amp;Query=PN%2F6307551">6307551</A></TD>
    <TD width="25%">Oct., 2001</TD>
    <TD align=left width="25%">Gueziec et al.</TD>
    <TD align=right width="25%">345/419. </TD></TR>
  <TR>
    <TD align=middle colSpan=4><B>Foreign Patent Documents</B></TD></TR>
  <TR>
    <TD width="25%">2070934</TD>
    <TD width="25%">Dec., 1993</TD>
    <TD align=left width="25%">CA. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">1 074 945</TD>
    <TD width="25%">Feb., 2001</TD>
    <TD align=left width="25%">EP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">1 075 146</TD>
    <TD width="25%">Feb., 2001</TD>
    <TD align=left width="25%">EP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">1 081 649</TD>
    <TD width="25%">Mar., 2001</TD>
    <TD align=left width="25%">EP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">9-330230</TD>
    <TD width="25%">Dec., 1997</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11053580</TD>
    <TD width="25%">Feb., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11076614</TD>
    <TD width="25%">Mar., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11161819</TD>
    <TD width="25%">Jun., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11203500</TD>
    <TD width="25%">Jul., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11226257</TD>
    <TD width="25%">Aug., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11259671</TD>
    <TD width="25%">Sep., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">11259678</TD>
    <TD width="25%">Sep., 1999</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-66985</TD>
    <TD width="25%">Mar., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-92390</TD>
    <TD width="25%">Mar., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-132704</TD>
    <TD width="25%">May., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-132706</TD>
    <TD width="25%">May., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-149053</TD>
    <TD width="25%">May., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-156875</TD>
    <TD width="25%">Jun., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-182077</TD>
    <TD width="25%">Jun., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-207582</TD>
    <TD width="25%">Jul., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">2000-215325</TD>
    <TD width="25%">Aug., 2000</TD>
    <TD align=left width="25%">JP. </TD>
    <TD align=right width="25%"></TD></TR>
  <TR>
    <TD width="25%">WO 94/10641</TD>
    <TD width="25%">May., 1994</TD>
    <TD align=left width="25%">WO. </TD>
    <TD align=right width="25%"></TD></TR></TBODY></TABLE><BR>
<TABLE width="90%"><BR>
  <CENTER><B>Other References</B></CENTER>
  <TBODY>
  <TR>
    <TD align=left><BR>Photograph of Sony PlayStation II System. 
      <BR>Photograph of Sega Dreamcast System. <BR>Photograph of 
      <B><I>Nintendo</I></B> 64 System. <BR>Whitepaper: 3D Graphics Demystified, 
      Nov. 11, 1999, www.nvidia.com. <BR>Whitepaper: "Z Buffering, Interpolation 
      and More W-Buffering", Doug Rogers, Jan. 31, 2000, www.nvidia.com. 
      <BR>Whitepaper: Using GL_NV_vertex_array and GL_NV_fence, posted Aug. 1, 
      2000, www.nvidia.com. <BR>Whitepaper: Anisotropic Texture Filtering in 
      OpenGL, posted Jul. 17, 2000, www.nvidia.com. <BR>Whitepaper: Mapping 
      Texels to Pixels in D3D, posted Apr. 5, 2000, www.nvidia.com. 
      <BR>Whitepaper: Guard Band Clipping, posted Jan. 31, 2000, www.nvidia.com. 
      <BR>Whitepaper: Cube Environment Mapping, posted Jan. 14, 2000, 
      www.nvidia.com. <BR>Whitepaper: Color Key in D3D, posted Jan. 11, 2000, 
      www.nvidia.com. <BR>Whitepaper: Vertex Blending Under DX7 for the GeForce 
      256, Jan. 5, 2000, www.nvidia.com. <BR>Whitepaper: Optimizing Direct3D for 
      the GeForce 256, Jan. 3, 2000, www.nvidia.com. <BR>Whitepaper: Dot Product 
      Texture Blending, Dec. 3, 1999, www.nvidia.com. <BR>Whitepaper: Technical 
      Brief: AGP 4X with Fast Writes, Nov. 10, 1999, www.nvidia.com. 
      <BR>Technical Brief: Transform and Lighting, Nov. 10, 1999, 
      www.nvidia.com. <BR>Technical Brief: What's New With Microsoft Direct X7, 
      posted Nov. 10, 1999, www.nvidia.com. <BR>Mitchell et al., "Multitexturing 
      in DirectX6", Game Developer, Sep. 1998, www.gdmag.com. <BR>VisionTek, 
      "GeForce2 GS Graphics Processing Unit", .COPYRGT.2000 www.visiontek.com. 
      <BR>Jim Bushnell et al. "Advanced Multitexture Effects With Direct3D and 
      OpenGL", Pyramid Peak Design &amp; ATI Research, Inc., GameDevelopers 
      Conference, .COPYRGT.1999. <BR>Sony PlayStation II Instruction Manual, 
      Sony Computer Entertainment Inc., .COPYRGT.2000. <BR>Stand and Be Judged, 
      Next Generation, May 2000. <BR>PlayStation II: Hardware Heaven or Hell?, 
      Next Generation, Jan. 2000. <BR>Chris Charla, "Play Station II: The Latest 
      News", Next Generation, Sep. 1999. <BR>"First PlayStation II Gameplay 
      Screens Revealed!", Next Generation, Sep. 1999. <BR>Game Enthusiast Online 
      Highlights, Mar. 18, 1999. <BR>Game Enthusiast Online Highlights, Mar. 19, 
      1999. <BR>Game Enthusiast Online Highlights, Mar. 17, 1999. <BR>Game 
      Enthusiast Online Highlights, Oct. 20, 1999. <BR>Joel Easley, "PlayStation 
      II Revealed", Game Week, Sep. 29, 1999. <BR>Inside Sony's Next Generation 
      Playstation, .COPYRGT.1999. <BR>Press Releases, Mar. 18, 1999. <BR>Chris 
      Johnston, "PlayStation Part Deux", Press Start, .COPYRGT.1999. <BR>Nikkei 
      Shimbun, "Sony Making SME, Chemical and SPT into Wholly-Owned 
      Subsidiaries", Mar. 9, 1999. <BR>AM News: Japanese Developers Not All Sold 
      on PS2, Next Generation, Mar. 16, 1999. <BR>Sony To Turn PlayStation Maker 
      Into Wholly Owned Unit-Nikkei, Dow Jones News Service, Mar. 8, 1999. 
      <BR>Yumiko Ono, Sony Antes Up Its Chips In Bet On New Game System, Dow 
      Jones News Service, Mar. 4, 1999. <BR>MacWeek.Com Gets Inside Story on 
      Connectix VGS for Windows; Controversial Emulator of Sony PlayStation 
      Games Cureently Available for Macs Only, Business Wire, Mar. 12, 1999. 
      <BR>"DexDrive Bridges Gap", The Tampa Tribune, Mar. 12, 1999. <BR>A 
      Microprocessor With a 128b CPU, 10 Floating-Point MAC's, 4 Floating-Point 
      Dividers, and an MPEG2 Decoder, 1999 IEEE International Solid-State 
      Circuits Conference, Feb. 16, 1999. <BR>Dreamcast Instruction Manual, Sega 
      Enterprises, Ltd., .COPYRGT.1998. <BR>"Sega To Launch Video Camera for 
      Dreamcast", Reuters Business News, Feb. 16, 2000. <BR>David Pescovitz, 
      "Dream On", Wired, Aug. 1999. <BR>Randy Nelson, "Dreamcast 101: Everything 
      You Ever Wanted To Know About Sega's Powerful New Console", Official Sega 
      Dreamcast Magazine, Jun. 1999. <BR>2D/3D Graphics Card User Manual, 
      Guillemot .COPYRGT.1999. <BR><B><I>Nintendo</I></B> 64 Instruction Booklet 
      <B><I>Nintendo</I></B> of America, 1998. <BR>Steven Levy, "Here Comes 
      PlayStation II", Newsweek, Mar. 6, 2000. <BR>David Sheff, "Sony Smackage: 
      Test Driving The PlayStation II", Wired, Nov. 1999. <BR>Introducing The 
      Next Generation PlayStation, Sony Computer Entertainment Inc., 
      .COPYRGT.1999. <BR>Leadtek GTS, Aug. 3, 2000, www.hexus.net. <BR>Voodoo 5 
      5500 Review, Jul. 26, 2000, www.hexus.net. <BR>ATI Radeon 64 Meg DDR OEM, 
      Aug., 19, 2000, www.hexus.net. <BR>Microsoft Xbox--The Future of Gaming, 
      Microsoft Xbox Performance Sheet, www.xbox.com. <BR>Robert L. Cook, "Shade 
      Trees", Computer Graphics, vol. 18, No. 3, Jul. 1984. <BR>Wang et al., 
      "Second-Depth Shadow Mapping", Department of Computer Science, Univ. N.C, 
      Chapel Hill, N.C. pp. 1-7. <BR>Peercy et al., "Efficient Bump Mapping 
      Hardware", Computer Graphics Proceedings, Annual Conference Series, 1997. 
      <BR>Gustavo Oliveira, "Refractive Texture Mappig, Part One", 
      www.gamasutra.com, Nov., 10, 2000. <BR>John Schlag, Fast Embossing Effects 
      on Raster Image Data, Graphics Gems IV, Edited by Paul S. Heckbert, 
      Computer Science Department, Carnegie Mellon University, Academic Press, 
      Inc. 1994,pp. 433-437. <BR>James F. Blinn, "Simulationof Wrinkled 
      Surfaces," Caltech/JPL, pp. 286-292, SIGGRAPH 78 (1978). <BR>Tomas Moller 
      and Eric Haines "Real-Time Rendering", AK Peter, Ltd., .COPYRGT.1999, pp. 
      127-142. <BR>Technical Presentation: Vertex Buffers, posted Jun. 12, 2000, 
      www.nvidia.com. <BR>Technical Presentation: Hardware Transform and 
      Lighting, www.nvidia.com, posted Jun. 12, 2000. <BR>Technical 
      Presentation: Hardware Bump-mapping Choices and Concepts, Jun. 7, 2000, 
      www.nvidia.com. <BR>Technical Presentation: How to Bump Map a Skinned 
      Polygonal Model, Jun. 7, 2000, www.nvidia.com. <BR>Technical Presentation: 
      Computations for Hardware Lighting and Shading, Mar. 17, 2000, 
      www.nvidia.com. <BR>Technical Presentation: Practical Bump-mapping for 
      Today's GPUs, Mar. 17, 2000 www.nvidia.com. <BR>Technical Presentation: 
      Shadows, Transparency, &amp; Fog, Mar. 17, 2000 www.nvidia.com. 
      <BR>Technical Presentation: GeForce 256 Register Combiners, Mar. 17, 2000, 
      www.nvidia.com. <BR>Technical Presentation: TexGen &amp; The Texture 
      Matrix, Mar. 15, 2000 www.nvidia.com. <BR>Technical Presentation: Toon 
      Shading, Mar. 15, 2000, www.nvidia.com. <BR>Technical Presentation: D3D 7 
      Vertex Lighting, Mar. 15, 2000, www.nvidia.com. <BR>Technical 
      Presentation: Per-Pixel Lighting (by S. Dietrich) Mar. 14, 2000 
      www.nvidia.com. <BR>Technical Presentation: GeForce 256 and RIVA TNT 
      Combiners, Dec. 8, 1999, www.nvidia.com. <BR>Technical Presentation: 
      Vertex Cache Optimization, Nov. 12, 1999, www.nvidia.com. <BR>Technical 
      Presentation: Vertex Blending, Nov. 12, 1999, www.nvidia.com. 
      <BR>Technical Presentation: Hardware Transform and Lighting, Nov. 12, 
      1999, www.nvidia.com. <BR>Technical Presentation: GeForce 256 Overview, 
      Nov. 12, 1999, www.nvidia.com. <BR>Technical Presentation: DirectX 7 and 
      Texture Management, Nov. 12, 1999 www.nvidia.com. <BR>Technical 
      Presentation: Dot Product Lighting, Nov. 12, 1999, www.nvidia.com. 
      <BR>Technical Presentation: Texture Coordinate Generation, Nov. 3, 1999, 
      www.nvidia.com. <BR>Technical Presentation: Phong Shading and Lightmaps, 
      Nov. 3, 1999, www.nvidia.com. <BR>Technical Presentation: The 
      ARB_multitexture Extension, Nov. 3, 1999 www.nvidia.com. <BR>Technical 
      Presentation: Multitexture Combiners, Nov. 3, 1999, www.nvidia.com. 
      <BR>Technical Presentation: Emboss Bump Mapping, Nov. 3, 1999, 
      www.nvidia.com. <BR>Technical Presentation: Hardware Accelerated 
      Anisotropic Lighting, Nov. 3, 1999 www.nvidia.com. <BR>Technical 
      Presentation: Guard Band Clipping, Nov. 3, 1999, www.nvidia.com. <BR>The 
      RenderMan Interface, Stephan R. Keith, Version 3.1, Pixar Animation 
      Studios, Sep. 1989. <BR>The RenderMan Interface, Version 3.2, Pixar 
      Animation Studios, Jul. 2000, www.pixar.com. <BR>NVIDIA Product Overview, 
      "GeForce2Ultra", NVIDIA Corporation, Aug. 21, 2000, www.nvidia.com. 
      <BR>Duke, "Dreamcast Technical Specs", Sega Dreamcast Review, Sega, 2/99, 
      www.game-revolution.com. <BR>Marlin Rowley, "GeForce 1 &amp; 2 GPU Speed 
      Tests", May 11, 2000, www.g256.com. <BR>"Dreamcast: The Full Story", Next 
      Generation, Sep. 1998. <BR>DirectX 7.0 Programmer's Reference, Microsoft 
      Corportion, 1995-1999 (as part of the DirectX 7.0 SDK on the Companion CD 
      included with "Inside Direct3D", Microsoft Programming Series, Peter J. 
      Kovach, Microsoft Press, 1999). <BR>"Inside Direct3D", Microsoft 
      Programming Series, Peter J. Kovach, Microsoft Press, 1999. <BR>"OpenGL 
      Programming Guide, The Official Guide to Learning OpenGL, Release 1", 
      Jackie Nieder, Tom David, Mason Woo, Addision-Wesley Publishing Co., 1993. 
      <BR>"Procedural Elements for Computer Graphics," Second Edition, David F. 
      Rogers, McGraw Hill, 1998. <BR>"Real-Time Rendering," Tomas Molleir, Eric 
      Haines, AK Peters, 1999. <BR>"Computer Graphics, Principles and Practice," 
      Second Edition, The Systems Programming Series, Foley, van Dam, Fiener, 
      Hughes, Addison Wesley, 1990. <BR>"Principles of Three-Dimensional 
      Computer Animation", Revised Edition, Michael O'Rourke, W.W. Norton &amp; 
      Company, 1998. </TD></TR></TBODY></TABLE><BR><I>Primary Examiner:</I> Chauhan; 
Ulka <BR><I>Attorney, Agent or Firm:</I> Nixon &amp; Vanderhye P.C. <BR>
<HR>

<CENTER><B><I>Parent Case Text</B></I></CENTER>
<HR>
<BR><BR>This application is a continuation of application Ser. No. 09/723,336, 
filed Nov. 28, 2000. <BR><BR>CROSS-REFERENCE TO RELATED APPLICATIONS <BR><BR>See 
the following copending patent applications incorporated herein by reference: 
<BR><BR>application Ser. No. 09/465,754, filed Dec. 17, 1999 of Moore et al. 
entitled "Vertex Cache For 3D Computer Graphics"; claiming benefit from 
provisional application Ser. No. 60/161,915, filed Oct. 28, 1999, 
<BR><BR>application Ser. No.09/726,215, filed Nov. 28, 2000 (atty. dkt. no. 
723-959), of Fouladi et al. entitled "Method and Apparatus for Buffering 
Graphics Data in a Graphics System" claiming benefit from provisional 
application Ser. No. 60/226,912 filed Aug. 23, 2000; <BR><BR>application Ser. 
No. 09/722,367, filed Nov. 28, 2000 (atty. dkt. no. 723-968) of Drebin et al. 
entitled "Recirculating Shade Tree Blender For A Graphics System" claiming 
benefit from provisional application Ser. No. 60/226,888, filed Aug. 23, 2000; 
<BR><BR>application Ser. No. 09/722,663, filed Nov. 28, 2000 (atty. dkt. no. 
723-963) of Fouladi et al. entitled "Graphics System With Copy Out Conversions 
Between Embedded Frame Buffer And Main Memory" claiming benefit from provisional 
application Ser. No. 60/227,030, filed Aug. 23, 2000; <BR><BR>application Ser. 
No. 09/722,390, filed Nov. 28, 2000 (atty. dkt. no. 723-972) of Demers, entitled 
"Low Cost Graphics System With Stitching Hardware Support For Skeletal 
Animation" claiming benefit from provisional application Ser. No. 60/226,914, 
filed Aug. 23, 2000; <BR><BR>application Ser. No. 09/726,216, filed Nov. 28, 
2000 (atty. dkt. no. 723-967) of Drebin et al., entitled "Achromatic Lighting in 
a Graphics System and Method" claiming benefit from provisional application Ser. 
No. 60/227,007, filed Aug. 23, 2000. 
<HR>

<CENTER><B><I>Claims</B></I></CENTER>
<HR>
<BR><BR>We claim: <BR><BR>1. A graphics command stream for use in a graphics 
system, the command stream being operable upon execution to load vertex 
attribute registers, the graphics command stream comprising: <BR><BR>a graphics 
command 0x 0870 followed by a 4-byte value including attribute information for 
position, normal, a first color, a second color, a texture 0 coordinate, and 
further including a byte dequantization flag and a normal index flag, and 
<BR><BR>at least one additional stream command defining at least one texture 
coordinate attribute, <BR><BR>wherein upon execution of the graphics command 
stream the vertex attribute registers are loaded. <BR><BR>2. A computer readable 
storage medium encoded with executable instructions for loading vertex attribute 
registers, comprising: <BR><BR>a graphics command 0x0870 followed by a 4-byte 
value including attribute information for position, normal, a first color, a 
second color, a texture 0 coordinate, and further including a byte 
dequantization flag and a normal index flag, and <BR><BR>at least one additional 
stream command defining at least one texture coordinate attribute, 
<BR><BR>wherein execution of the encoded instructions loads the vertex attribute 
registers. <BR><BR>3. A graphics command stream decoder comprising: <BR><BR>a 
first decoding section decoding a graphics command 0x0870 followed by a 4-byte 
value including attribute information for position, normal, a first color, a 
second color, a texture 0 coordinate, and further including a byte 
dequantization flag and a normal index flag, and <BR><BR>at least one addtional 
decoding section decoding at least one additional stream command defining at 
least one texture coordinate attribute. <BR><BR>4. A method of loading vertex 
attribute registers in a graphics system using a graphics command stream, the 
method comprising: <BR><BR>generating a graphics command 0x0870 followed by a 
4-byte value including attribute information for position, normal, a first 
color, a second color, a texture 0 coordinate, and further including a byte 
dequantization flag and a normal index flag, and <BR><BR>generating at least one 
additional stream command defining at least one texture coordinate attribute, 
<BR><BR>wherein upon execution of the graphics command stream the vertex 
attribute registers are loaded. 
<HR>

<CENTER><B><I>Description</B></I></CENTER>
<HR>
<BR><BR>FIELD OF THE INVENTION <BR><BR>The present invention relates to computer 
graphics, and more particularly to interactive graphics systems including but 
not limited to home video game platforms. Still more particularly this invention 
relates to an advantageous software programming interface including binary 
command functions for controlling a graphics chip and to methods for generating, 
storing and decoding same. <BR><BR>BACKGROUND AND SUMMARY OF THE INVENTION 
<BR><BR>Many of us have seen films containing remarkably realistic dinosaurs, 
aliens, animated toys and other fanciful creatures. Such animations are made 
possible by computer graphics. Using such techniques, a computer graphics artist 
can specify how each object should look and how it should change in appearance 
over time, and a computer then models the objects and displays them on a display 
such as your television or a computer screen. The computer takes care of 
performing the many tasks required to make sure that each part of the displayed 
image is colored and shaped just right based on the position and orientation of 
each object in a scene, the direction in which light seems to strike each 
object, the surface texture of each object, and other factors. <BR><BR>Because 
computer graphics generation is complex, computer-generated three-dimensional 
graphics just a few years ago were mostly limited to expensive specialized 
flight simulators, high-end graphics workstations and supercomputers. The public 
saw some of the images generated by these computer systems in movies and 
expensive television advertisements, but most of us couldn't actually interact 
with the computers doing the graphics generation. All this has changed with the 
availability of relatively inexpensive 3D graphics platforms such as, for 
example, the <B><I>Nintendo</I></B> 64.RTM. and various 3D graphics cards now 
available for personal computers. It is now possible to interact with exciting 
3D animations and simulations on relatively inexpensive computer graphics 
systems in your home or office. <BR><BR>A problem graphics system designers 
confronted in the past was how to provide a control interface for a graphics 
system that enables fast, efficient and flexible use of the graphics system by 
applications designed to be executed thereon. Various application programming 
interfaces (APIs) and application binary interfaces (ABIs) have been developed 
in the past for the purpose of enabling graphics application programmers to 
control the operation of a graphics chip provided in a graphics system. Perhaps 
the most commonly-used 3D graphics application programming interfaces in current 
use are Microsoft's Direct3D interface and the OpenGL interface developed 
through cooperation with Silicon Graphics. See, for example, Kovach, Inside 
Direct3D: The Definitive Guide to Real-Time 3D Power and Performance for 
Microsoft Windows (Microsoft Press 2000); and Neider et al., OpenGL Programming 
Guide: The Official Guide to Learning OpenGL Release 1 (Addison-Wesley 
Publishing Co. 1993). <BR><BR>As explained in the Kovach book, Microsoft's 
DirectX application programming interface (API) provides a set of interfaces 
offering efficient control of multimedia hardware on a computer running 
Microsoft Windows. Kovach states that DirectX lets programmers work with 
commands and data structures that are very close to those that the hardware can 
natively process, without being so low level that code has to be written 
differently for each device. By writing device-independent code, programmers can 
create software that will theoretically always perform at its best (according to 
Kovach)--even as users enhance their systems with new and improved 3D graphics 
accelerators, sound cards, input devices and other system capabilities. 
<BR><BR>Kovach explains that the device-independence of DirectX is obtained 
because the DirectX APIs are built on a hardware abstraction layer (HAL) that 
hides the device-specific dependencies of the hardware. In fact, DirectX defines 
some hardware acceleration support features that aren't available on much of the 
hardware built today in order to provide extensibility for the future. 
<BR><BR>While the DirectX approach has been widely adopted and is successful in 
providing compatibility across a wide range of different platform 
configurations, the use of a thick hardware abstraction layer and associated 
hardware emulation layer is not particularly suitable for current low cost 
dedicated video game platforms at the current time. The DirectX API was 
primarily designed for personal computers costing many hundreds or thousands of 
dollars and manufactured in a variety of different configurations and 
permutations. While the DirectX API has been successful in providing 
compatibility across a wide range of such different platform configurations, 
this compatibility has come at the expense of efficiency and performance. In the 
context of a dedicated low-cost video game platform, it is possible to do much 
better in terms of providing a fully capable programming interface that is very 
close to the hardware while providing a highly capable and flexible interface 
for achieving a wide variety of interesting 3-dimensional graphics effects. 
<BR><BR>One prior approach is described in U.S. patent application Ser. No. 
08/990,133 filed Dec. 12, 1997 by Van Hook et al., entitled "Interface For A 
High Performance Low Cost Video Game System With Coprocessor Providing High 
Speed Efficient 3D Graphics And Digital Audio Signal Processing." However, 
further improvements are possible and desirable. In particular, some people 
criticized the interface described in this prior Van Hook et al., patent 
application because they thought it was difficult to write applications to. In 
the home video game arena, it is desirable to maximize performance while keeping 
the interface used to invoke and control such performance and capabilities as 
simple and easy to use as possible. Requiring application programmers to write 
to an unduly complicated interface may increase the time it takes to develop 
such applications. This can have devastatingly negative effects when it comes 
time to launch a new video game platform--since the success of the platform may 
often depend on achieving a certain "critical mass" in terms of the number of 
games or other applications available at launch time. As some developers of 
prior new home video game platforms found out, no one wants to buy a new video 
game system if there are no games to play on it. It is therefore desirable to 
provide a graphics programming interface that is simple and easy to use and yet 
is very powerful and flexible. <BR><BR>The present invention solves this problem 
by providing new and improved interface for graphics systems that is designed to 
be as thin as possible in order to achieve high performance, while also 
providing a logical and orthogonal view of the graphics hardware. <BR><BR>The 
present invention provides a graphics system programming interface with graphics 
commands allowing geometry to be rendered with many attributes. The interface 
provides two main methods for drawing geometry. An immediate mode allows the 
command stream source to send a stream of graphics commands directly to the 
graphics processor for consumption. This immediate mode interface is useful when 
the main processor must synthesize geometry data from a higher-level description 
(e.g., a height field or Bezier patch). The second method feeds a command stream 
to the graphics processor using a memory-resident display list format. This 
interface provides superior performance for static data. The immediate interface 
and the display list interface both support configurable vertex representations. 
The configurable vertex representations include, for example, direct or indexed 
vertex components. Vertex components (e.g., position, normal, color and texture 
coordinates for a number of textures) can all be indexed independently from 
arrays, or placed directly in the command stream. Additional flexibility is 
provided by allowing each vertex component to have a differently-sized 
representation and precision. The available direct types may include, for 
example, 8-bit signed and unsigned integer, 16-bit signed and unsigned integer, 
and 32-bit floating point. A scale is available to position the decimal point 
for the integer types. The indirect types (e.g., 8-bit index or 16-bit index) 
can be used to index into an array of any of the direct types. This flexible 
representation allows the game developer to organize vertex data in a way that 
is appropriate for the game. The ability to index each component separately 
eliminates a great deal of data duplication. <BR><BR>BRIEF DESCRIPTION OF THE 
DRAWINGS <BR><BR>These and other features and advantages provided by the 
invention will be better and more completely understood by referring to the 
following detailed description of presently preferred embodiments in conjunction 
with the drawings, of which: <BR><BR>FIG. 1 is an overall view of an example 
interactive computer graphics system; <BR><BR>FIG. 2 is a block diagram of the 
FIG. 1 example computer graphics system; <BR><BR>FIG. 3 is a block diagram of 
the example graphics and audio processor shown in FIG. 2; <BR><BR>FIG. 4 is a 
block diagram of the example 3D graphics processor shown in FIG. 3; <BR><BR>FIG. 
5 is an example logical flow diagram of the FIG. 4 3D graphics processor; 
<BR><BR>FIG. 6 is a general flow chart of functions performed by an example 
application for the FIG. 1 graphics system; <BR><BR>FIG. 7 is a flow chart 
showing the functions of FIG. 6 in more detail; <BR><BR>FIG. 8 shows example 
simple graphics command stream; <BR><BR>FIG. 9 shows an example binary level 
interface for setting the embedded color and depth buffer of the FIG. 1 system 
to a particular (e.g., initial) value; <BR><BR>FIG. 9A shows example pixel 
engine copy clear register formats; <BR><BR>FIG. 10 shows an example vertex data 
structure hierarchy including example description information; <BR><BR>FIG. 11 
shows an example binary level interface defining a vertex attribute array; 
<BR><BR>FIG. 12 shows an example binary level interface defining a vertex 
descriptor; <BR><BR>FIGS. 13A and 13B together show an example binary level 
interface defining a vertex attribute table; <BR><BR>FIG. 14 schematically 
illustrates an example vertex attribute format table; <BR><BR>FIG. 15 shows 
example graphics primitives that may be represented using the vertex data 
structures herein; <BR><BR>FIG. 16 shows an example binary level interface 
defining a projection matrix; <BR><BR>FIG. 17 shows an example binary level 
interface defining a display list to be called; and <BR><BR>FIGS. 18A and 18B 
show example alternative compatible implementations. <BR><BR>DETAILED 
DESCRIPTION OF EXAMPLE EMBODIMENTS OF THE INVENTION <BR><BR>FIG. 1 shows an 
example interactive 3D computer graphics system 50. System 50 can be used to 
play interactive 3D video games with interesting stereo sound. It can also be 
used for a variety of other applications. <BR><BR>In this example, system 50 is 
capable of processing, interactively in real time, a digital representation or 
model of a three-dimensional world. System 50 can display some or all of the 
world from any arbitrary viewpoint. For example, system 50 can interactively 
change the viewpoint in response to real time inputs from handheld controllers 
52a, 52b or other input devices. This allows the game player to see the world 
through the eyes of someone within or outside of the world. System 50 can be 
used for applications that do not require real time 3D interactive display 
(e.g., 2D display generation and/or non-interactive display), but the capability 
of displaying quality 3D images very quickly can be used to create very 
realistic and exciting game play or other graphical interactions. <BR><BR>To 
play a video game or other application using system 50, the user first connects 
a main unit 54 to his or her color television set 56 or other display device by 
connecting a cable 58 between the two. Main unit 54 produces both video signals 
and audio signals for controlling color television set 56. The video signals are 
what controls the images displayed on the television screen 59, and the audio 
signals are played back as sound through television stereo loudspeakers 61L, 
61R. <BR><BR>The user also needs to connect main unit 54 to a power source. This 
power source may be a conventional AC adapter (not shown) that plugs into a 
standard home electrical wall socket and converts the house current into a lower 
DC voltage signal suitable for powering the main unit 54. Batteries could be 
used in other implementations. <BR><BR>The user may use hand controllers 52a, 
52b to control main unit 54. Controls 60 can be used, for example, to specify 
the direction (up or down, left or right, closer or further away) that a 
character displayed on television 56 should move within a 3D world. Controls 60 
also provide input for other applications (e.g., menu selection, pointer/cursor 
control, etc.). Controllers 52 can take a variety of forms. In this example, 
controllers 52 shown each include controls 60 such as joysticks, push buttons 
and/or directional switches. Controllers 52 may be connected to main unit 54 by 
cables or wirelessly via electromagnetic (e.g., radio or infrared) waves. 
<BR><BR>To play an application such as a game, the user selects an appropriate 
storage medium 62 storing the video game or other application he or she wants to 
play, and inserts that storage medium into a slot 64 in main unit 54. Storage 
medium 62 may, for example, be a specially encoded and/or encrypted optical 
and/or magnetic disk that stores commands for graphics and audio processor 114 
and/or instructions controlling main processor 110 to develop such commands. The 
user may operate a power switch 66 to turn on main unit 54 and cause the main 
unit to begin running the video game or other application based on the software 
stored in the storage medium 62. The user may operate controllers 52 to provide 
inputs to main unit 54. For example, operating a control 60 may cause the game 
or other application to start. Moving other controls 60 can cause animated 
characters to move in different directions or change the user's point of view in 
a 3D world. Depending upon the particular software stored within the storage 
medium 62, the various controls 60 on the controller 52 can perform different 
functions at different times. <BR><BR>EXAMPLE ELECTRONICS OF OVERALL SYSTEM 
<BR><BR>FIG. 2 shows a block diagram of example components of system 50. The 
primary components include: <BR><BR>a main processor (CPU) 110, <BR><BR>a main 
memory 112, and <BR><BR>a graphics and audio processor 114. <BR><BR>In this 
example, main processor 110 (e.g., an enhanced IBM Power PC 750) receives inputs 
from handheld controllers 108 (and/or other input devices) via graphics and 
audio processor 114. Main processor 110 interactively responds to user inputs, 
and executes a video game or other program supplied, for example, by external 
storage media 62 via a mass storage access device 106 such as an optical disk 
drive. As one example, in the context of video game play, main processor 110 can 
perform collision detection and animation processing in addition to a variety of 
interactive and control functions. <BR><BR>In this example, main processor 110 
generates 3D graphics and audio commands and sends them to graphics and audio 
processor 114. The graphics and audio processor 114 processes these commands to 
generate interesting visual images on display 59 and interesting stereo sound on 
stereo loudspeakers 61R, 61L or other suitable sound-generating devices. 
<BR><BR>Example system 50 includes a video encoder 120 that receives image 
signals from graphics and audio processor 114 and converts the image signals 
into analog and/or digital video signals suitable for display on a standard 
display device such as a computer monitor or home color television set 56. 
System 100 also includes an audio codec (compressor/decompressor) 122 that 
compresses and decompresses digitized audio signals and may also convert between 
digital and analog audio signaling formats as needed. Audio codec 122 can 
receive audio inputs via a buffer 124 and provide them to graphics and audio 
processor 114 for processing (e.g., mixing with other audio signals the 
processor generates and/or receives via a streaming audio output of mass storage 
access device 106). Graphics and audio processor 114 in this example can store 
audio related information in an audio memory 126 that is available for audio 
tasks. Graphics and audio processor 114 provides the resulting audio output 
signals to audio codec 122 for decompression and conversion to analog signals 
(e.g., via buffer amplifiers 128L, 128R) so they can be reproduced by 
loudspeakers 61L, 61R. <BR><BR>Graphics and audio processor 114 has the ability 
to communicate with various additional devices that may be present within system 
100. For example, a parallel digital bus 130 may be used to communicate with 
mass storage access device 106 and/or other components. A serial peripheral bus 
132 may communicate with a variety of peripheral or other devices including, for 
example: <BR><BR>a programmable read-only memory and/or real time clock 134, 
<BR><BR>a modem 136 or other networking interface (which may in turn connect 
system 100 to a telecommunications network 138 such as the Internet or other 
digital network from/to which program instructions and/or data can be downloaded 
or uploaded), and <BR><BR>flash memory 140. <BR><BR>A further external serial 
bus 142 may be used to communicate with additional expansion memory 144 (e.g., a 
memory card) or other devices. Connectors may be used to connect various devices 
to busses 130, 132, 142. <BR><BR>EXAMPLE GRAPHICS AND AUDIO PROCESSOR 
<BR><BR>FIG. 3 is a block diagram of an example graphics and audio processor 
114. Graphics and audio processor 114 in one example may be a single-chip ASIC 
(application specific integrated circuit). In this example, graphics and audio 
processor 114 includes: <BR><BR>a processor interface 150, <BR><BR>a memory 
interface/controller 152, <BR><BR>a 3D graphics processor 154, <BR><BR>an audio 
digital signal processor (DSP) 156, <BR><BR>an audio memory interface 158, 
<BR><BR>an audio interface and mixer 160, <BR><BR>a peripheral controller 162, 
and <BR><BR>a display controller 164. <BR><BR>3D graphics processor 154 performs 
graphics processing tasks. Audio digital signal processor 156 performs audio 
processing tasks. Display controller 164 accesses image information from main 
memory 112 and provides it to video encoder 120 for display on display device 
102. Audio interface and mixer 160 interfaces with audio codec 122, and can also 
mix audio from different sources (e.g., streaming audio from mass storage access 
device 106, the output of audio DSP 156, and external audio input received via 
audio codec 122). Processor interface 150 provides a data and control interface 
between main processor 110 and graphics and audio processor 114. <BR><BR>Memory 
interface 152 provides a data and control interface between graphics and audio 
processor 114 and memory 112. In this example, main processor 110 accesses main 
memory 112 via processor interface 150 and memory interface 152 that are part of 
graphics and audio processor 114. Peripheral controller 162 provides a data and 
control interface between graphics and audio processor 114 and the various 
peripherals mentioned above. Audio memory interface 158 provides an interface 
with audio memory 126. <BR><BR>EXAMPLE GRAPHICS PIPELINE <BR><BR>FIG. 4 shows a 
more detailed view of an example 3D graphics processor 154. 3D graphics 
processor 154 includes, among other things, a command processor 200 and a 3D 
graphics pipeline 180. Main processor 110 communicates streams of data (e.g., 
graphics command streams and display lists) to command processor 200. Main 
processor 110 has a two-level cache 112 to minimize memory latency, and also has 
a write-gathering buffer 111 for uncached data streams targeted for the graphics 
and audio processor 114. The write-gathering buffer 111 collects partial cache 
lines into fill cache lines and sends the data out to the graphics and audio 
processor 114 one cache line at a time for maximum bus usage. <BR><BR>Command 
processor 200 receives display commands in binary format from main processor 110 
and parses and decodes them--obtaining any additional data necessary to process 
them from shared memory 112. The command processor 200 provides a stream of 
vertex commands to graphics pipeline 180 for 2D and/or 3D processing and 
rendering. Graphics pipeline 180 generates images based on these commands. The 
resulting image information may be transferred to main memory 112 for access by 
display controller/video interface unit 164--which displays the frame buffer 
output of pipeline 180 on display 102. <BR><BR>FIG. 5 is a logical flow diagram 
of graphics processor 154. Main processor 110 may store graphics command streams 
210, display lists 212 and vertex arrays 214 in main memory 112, and pass 
pointers to command processor 200 via bus interface 150. The main processor 110 
stores graphics commands in one or more graphics first-in-first-out (FIFO) 
buffers 210 it allocates in main memory 10 or elsewhere. The command processor 
200 fetches: <BR><BR>command streams from main memory 112 via an on-chip FIFO 
memory buffer 216 that receives and buffers the graphics commands for 
synchronization/flow control and load balancing, <BR><BR>display lists 212 from 
main memory 112 via an on-chip call FIFO memory buffer 218, and <BR><BR>vertex 
attributes from the command stream and/or from vertex arrays 1000 in main memory 
112 via a vertex cache 220. <BR><BR>Command processor 200 performs command 
processing operations 200a that convert attribute types to floating point 
format, and passes the resulting complete vertex polygon data to graphics 
pipeline 180 for rendering/rasterization. A programmable memory arbitration 
circuitry 130 (see FIG. 4) arbitrates access to shared main memory 112 between 
graphics pipeline 180, command processor 200 and display controller/video 
interface unit 164. <BR><BR>FIG. 4 shows that graphics pipeline 180 may include: 
<BR><BR>a transform unit 300, <BR><BR>a setup/rasterizer 400, <BR><BR>a texture 
unit 500, <BR><BR>a texture environment unit 600, and <BR><BR>a pixel engine 
700. <BR><BR>Transform unit 300 performs a variety of 2D and 3D transform and 
other operations 300a (see FIG. 5). Transform unit 300 may include one or more 
matrix memories 300b for storing matrices used in transformation processing 
300a. Transform unit 300 transforms incoming geometry per vertex from object 
space to screen space; and transforms incoming texture coordinates and computes 
projective texture coordinates (300c). Transform unit 300 may also perform 
polygon clipping/culling 300d. Lighting processing 300e also performed by 
transform unit 300b provides per vertex lighting computations for up to eight 
independent lights in one example embodiment. Transform unit 300 can also 
perform texture coordinate generation (300c) for embossed type bump mapping 
effects, as well as polygon clipping/culling operations (300d). 
<BR><BR>Setup/rasterizer 400 includes a setup unit which receives vertex data 
from transform unit 300 and sends triangle setup information to one or more 
rasterizer units (400b) performing edge rasterization, texture coordinate 
rasterization and color rasterization. <BR><BR>Texture unit 500 (which may 
include an on-chip texture memory (TMEM) 502) performs various tasks related to 
texturing including for example: <BR><BR>retrieving textures 504 from main 
memory 112, <BR><BR>texture processing (500a) including, for example, 
multi-texture handling, post-cache texture decompression, texture filtering, 
embossing, shadows and lighting through the use of projective textures, and BLIT 
with alpha transparency and depth, <BR><BR>bump map processing for computing 
texture coordinate displacements for bump mapping, pseudo texture and texture 
tiling effects (500b), and <BR><BR>indirect texture processing (500c). 
<BR><BR>Texture unit 500 outputs filtered texture values to the texture 
environment unit 600 for texture environment processing (600a). Texture 
environment unit 600 blends polygon and texture color/alpha/depth, and can also 
perform texture fog processing (600b) to achieve inverse range based fog 
effects. Texture environment unit 600 can provide multiple stages to perform a 
variety of other interesting environment-related functions based for example on 
color/alpha modulation, embossing, detail texturing, texture swapping, clamping, 
and depth blending. <BR><BR>Pixel engine 700 performs depth (z) compare (700a) 
and pixel blending (700b). In this example, pixel engine 700 stores data into an 
embedded (on-chip) frame buffer memory 702. Graphics pipeline 180 may include 
one or more embedded DRAM memories 702 to store frame buffer and/or texture 
information locally. Z compares 700a' can also be performed at an earlier stage 
in the graphics pipeline 180 depending on the rendering mode currently in effect 
(e.g., z compares can be performed earlier if alpha blending is not required). 
The pixel engine 700 includes a copy operation 700c that periodically writes 
on-chip frame buffer 702 to main memory 112 for access by display/video 
interface unit 164. This copy operation 700c can also be used to copy embedded 
frame buffer 702 contents to textures in the main memory 112 for dynamic texture 
synthesis effects. Anti-aliasing and other filtering can be performed during the 
copy-out operation. The frame buffer output of graphics pipeline 180 (which is 
ultimately stored in main memory 112) is read each frame by display/video 
interface unit 164. Display controller/video interface 164 provides digital RGB 
pixel values for display on display 102. <BR><BR>EXAMPLE GRAPHICS SYSTEM 
APPLICATION INTERFACE <BR><BR>As described above, main processor 110 sends 
graphics commands to graphics and audio processor 114. These graphics commands 
tell the graphics and audio processor 114 what to do. For example, the graphics 
commands can tell the graphics and audio processor 114 to draw a particular 
image onto display device 56. Commands might also tell the graphics and audio 
processor 114 to produce a particular sound for output by loudspeakers 61. Still 
other commands might tell the graphics and audio processor 114 to perform 
so-called "housekeeping" commands and/or to set up a particular state in 
preparation for a subsequent "action" command. <BR><BR>In the example 
embodiment, the commands that main processor 110 sends to graphics and audio 
processor 114 can come from a number of sources. One source of commands is the 
main processor 110 itself. Under control of program instructions provided, for 
example, by mass storage access device 106 and/or boot ROM 134, main processor 
110 can dynamically create or generate graphics commands under program control 
to send to graphics and audio processor 114. Main processor 110 can create and 
send graphics and audio processor 114 any command that the graphics and audio 
processor understands. Graphics and audio processor 114 will act on the commands 
and perform the action requested by the command. <BR><BR>Another source of 
graphics commands for graphics and audio processor 114 is mass storage access 
device 106. It takes some time for main processor 110 to dynamically create 
graphics commands. When system 50 is animating a scene in response to real-time 
inputs from hand controllers 52 or the like, there may be no alternative other 
than for main processor 110 to dynamically create the graphics commands telling 
the graphics and audio processor 114 to draw a particular cartoon or other 
character in a particular position. That way, as the user operates hand 
controllers 52 of system 50 responds to other input devices, main processor 110 
can dynamically adjust or animate the displayed scene in response to those 
real-time inputs to provide interactive animation. Such fun and exciting 
interactive animation is generally provided by main processor 110 dynamically 
creating graphics commands "on the fly." <BR><BR>Sometimes, however, some part 
of a scene to be displayed is relatively static and does not change in response 
to real-time inputs. For example, a complicated 3D world background such as a 
castle, a mountain fortress, a landscape or an undersea world may not change 
much or at all as animated characters move through the world. In such cases, it 
is possible to use an offline authoring computer to develop the complex series 
of graphics commands required to draw the particular scene or portion of the 
scene and store them in a preconstructed display list. Similarly, sound effects, 
music and other sounds can be pre-generated off-line by a sound authoring 
system. The resulting display list(s) and/or audio list(s) can be stored on an 
optical disk 62 or other mass storage device. When it comes time to draw the 
scene and/or play the sound, the associated display list(s) and/or audio list(s) 
can simply be read from the mass storage device 62 and stored into main memory 
112. Main processor 110 may then, under program control, tell the graphics and 
audio processor 114 where to find the preconstructed display list(s) and/or 
audio list(s), and instruct the graphics and audio processor to execute the 
lists. In this way, main processor 110 does not have to devote its processing 
resources to develop complicated display lists and/or audio lists since that 
task is off-loaded to an off-line authoring system that pre-compiles the lists 
in preparation for use by the graphics and audio processor 114. Such display 
lists can be stored by any storage device within system 50 or accessible to it, 
including but not limited to memory card 144, flash memory 140, boot ROM 134, 
audio memory 126, etc. The commands could be embedded in hardware such as gate 
arrays or the like, and communicated to system 50 via any of the external 
interfaces such as bus 142, bus 132, handheld controller ports, parallel bus 
130, infrared, etc. <BR><BR>Still another possibility is for commands intended 
for processing by the graphics and audio processor 114 to arrive via a data 
communications connection such as network 138. In one example, graphics 
commands, audio commands and/or other commands intended to be processed by 
graphics and audio processor 114 may arrive from a data communications network 
138 via modem 136. Such commands could be transmitted, for example, from a 
remote system 50 of the same configuration as that shown in FIG. 2 in order to 
provide interactive multi-user remote game play. The commands could originate 
from any other source including a personal computer, a mini-computer or main 
frame computer, a data transmitter, or any other data source. 
<BR><BR>Irrespective of how commands intended for graphics and audio processor 
114 arrive and how they are stored before and/or after arrival, the first step 
in causing such commands to be processed by the graphics and audio processor 114 
is to make them available to the graphics and audio processor. In the example 
embodiment, making the commands available to graphics and audio processor 114 
can be accomplished either by having main processor 110 send the commands 
directly to the graphics and audio processor via a data bus in an immediate mode 
of command transfer, or by storing the commands in some memory accessible to the 
graphics and audio processor 114 (e.g., main memory 112, audio memory 126, or 
any other memory device to which the graphics and audio processor 114 is 
coupled) and informing the graphics and audio processor where to find the 
commands and instructing it to begin processing those commands. <BR><BR>GRAPHICS 
COMMAND STREAM <BR><BR>In the example embodiment, graphics and audio processor 
114 may receive register and other commands from main processor 110 and/or some 
other source (e.g., main memory 112) in the form of a graphics command stream. 
Generally, the data that is sent from main processor 110 to the graphics and 
audio processor 114 can be called the "command stream." The command stream holds 
drawing commands along with vertices and their attributes and mechanisms for 
loading registers and changing modes in the graphics pipeline 180. The stream of 
graphics commands are sent to the graphics and audio processor 114 for 
processing in a generally sequential manner. Such stream commands can be 
provided in a so-called "immediate mode" directly from main processor 110 to the 
graphics and audio processor 114 through a sprite gatherer arrangement (see FIG. 
4) to provide very efficient transfer of graphics and audio commands from the 
main processor 110 to the graphics and audio processor 114. The graphics command 
stream can also be provided to graphics and audio processor 114 via main memory 
112 or other memory or other data communications capabilities within system 50. 
The cache/command processor 200 within the graphics and audio processor 114 
performs tasks such as, for example, fetching the command stream from main 
memory 112; fetching vertex attributes (e.g., either from the command stream or 
from arrays in main memory); converting attribute types to appropriate formats 
(e.g., floating point); and transferring complete vertices to the remainder of 
the graphics pipeline 180 for processing. <BR><BR>As shown in FIG. 5, the 
command stream is fetched from the first-in-first-out buffer 210 (see also 
above-referenced Provisional Application No. 60/226,912, filed Aug. 23, 2000 and 
its corresponding utility Application No.09/726,215, filed Nov. 28, 2000 (atty. 
dkt. no. 723-959), both entitled "Method and Apparatus for Buffering Graphics 
Data in a Graphics System ", and read into a FIFO buffer 216. The command 
processor 200 strips and decodes the commands to decide the number of data 
associated with it. The data is then taken from the stream and/or fetched from 
an array in main memory 112, based on an index value. The vertex attributes are 
converted to floating point data that can be consumed by the transform engine 
300. <BR><BR>The following are example command stream formats in the example 
embodiment: <BR><BR><PRE>    TABLE I
    Opcode             Opcode(7:0)     Next              Followed by
    NOP                00000000        none              none
    Draw_Quads         10000vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Triangles     10010vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Triangle_strip 10011vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Triangle_fan  10100vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Lines         l0l0lvat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Line_strip    101l0vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    Draw_Points        10111vat(2:0)   VertexCount(15:0) Vertex attribute
     stream
    CP_LoadRegs        0000lxxx        Address[7:0]      32 bits data
    (for CP only registers)
    XF_LoadRegs        000l0xxx        none              (N+2)*32 bits
    (This is used for                                    First 32 bit:
    loading all XF                                       15:00 register address
     in XF
    registers, including                                   19:16 number of 32
     bit registers to be
    matrices. It can be                                   loaded (N+1, 0 means
     1, 0xff means 16)
    used to load matrices                                   31:20 unused
    with immediate data)                                   Next N+1 32 bits:
                                                         31:00 register data
    XF_IndexLoadRegA   00l00xxx        none              32 bits
    (registers are in the                                   11:0 register
     address in XF
    first 4K address space                                   15:12 number of 32
     bit data, (0 means 1,
    of the XF. It can be                                   0xff means 16)
    used to block load
    matrix and light                                     31:16 Index to the
     register Array A
    registers)
    XF_IndexLoadRegB   00l0lxxx        none              32 bits
    (registers are in the                                   11:0 register
     address in XF
    first 4K address space                                   15:12 number of 32
     bit data, (0 means 1,
    of the XF. It can be                                   0xff means 16)
    used to block load                                   31:16 Index to the
     register Array B
    matrix and light
    registers)
    XF_IndexLoadRegC   001l0xxx        none              32 bits
    (registers are in the                                   11:0 register
     address in XF
    first 4K address space                                   15:12 number of 32
     bit data. (0 means 1,
    of the XF. It can be                                   0xff means 16)
    used to block load                                   31:16 Index to the
     register Array C
    matrix and light
    registers)
    XF_IndexLoadRegD   00111xxx        none              32 bits
    (registers are in the                                   11:0 register
     address in XF
    first 4K address space                                   15:12 number of 32
     bit data, (0 means 1,
    of the XF. It can be                                   0xff means 16)
    used to block load                                   31:16 Index to the
     register Array D
    matrix and light
    registers)
    Call_Object        0l000xxx        none              2x32
                                                         25:5 address (need to
     be 32 byte align)
                                                         25:5 count (32 byte
     count)
    V$ Invalidate      0l00lxxx        none              none
    SU_ByPassCmd       0110,SUattr(3:0) none              32 bit data
    (This includes all the
    register load below XF
    and all setup unit
    commands, which
    bypass XF)
</PRE><BR><BR>As shown in Table I above, the graphics command stream can include 
register load commands. Register commands are, in general, commands that have 
the effect of writing particular state information to particular registers 
internal to the graphics and audio processor 114. The graphics and audio 
processor 114 has a number of internal registers addressable by main processor 
110. To change the state of the graphics and audio processor 114 in particular 
way, main processor can write a particular value to a particular register 
internal to the graphics and audio processor 114. Register commands have the 
advantage of allowing the graphics pipeline to retain drawing state information 
that main processor 110 can selectively change by sending further register load 
commands. <BR><BR>For example, the vertices in a draw command can all share the 
same vertex attribute data structure defining a number of attributes associated 
with a vertex. Sending all of the vertex attribute information before a draw 
command could be costly. It therefore may be desirable to store most of the 
common vertex types in registers within the graphics and audio processor 114 and 
to simply pass an index to the stored table. These tables may not need to be 
updated each time a new draw command is sent down, but may only need to be 
updated every once in a while. In the example embodiment, command processor 200 
holds a vertex command descriptor register (VCD) and a eight-entry vertex 
attribute table (VAT) defining whether the attribute is present and if so 
whether it is indexed or direct. A "load_VCD" register command is used to update 
the register whenever updating is necessary. <BR><BR>In certain situations, main 
processor 110 may also read the graphics and audio processor 114 internal 
registers to determine the state of the graphics and audio processor. For 
example, the main processor 110 can start and stop the graphics and audio 
processor 114 and/or determine its general status by reading from and/or writing 
to internal registers within the graphics and audio processor. Main processor 
110 can also load a number of graphics values (e.g., transformation matrices, 
pixel formats, vertex formats, etc.) by writing to registers within the graphics 
and audio processor 114. As another example, main processor 110 can write to a 
series of FIFO control registers within the graphics and audio processor 114 
that control where the graphics and audio processor 114 obtains further commands 
for processing. <BR><BR>The following are example command registers used for 
defining transformation matrices, vertex control data, vertex attribute tables, 
vertex arrays, vertex stride, and other state parameters: <BR><BR><PRE>    TABLE II
    Register name Register address[7:0]              Bit fields
    MatrixIndexA  0011xxxx                           5:0 index for
     position/normal matrix
                                                     11:6 index for tex0 matrix
                                                     17:12 index for tex1
     matrix
                                                     23:13 index for tex2
     matrix
                                                     29:24 index for tex3
     matrix
    MatrixIndexB  0100xxxx                           5:0 index for tex4 matrix
                                                     11:6 index for tex5 matrix
                                                     17:12 index for tex6
     matrix
                                                     23:18 index for tex7
     matrix
    VCD_Lo        0l0lxxxx                           16:00 VCD 12 to 0
                                                     0 PosMatIdx
                                                     I Tex0MatIdx
                                                     2 TexlMatIdx
                                                     3 Tex2atIdx
                                                     4 Tex3MatIdx
                                                     5 Tex4MatIdx
                                                     6 Tex5MatIdx
                                                     7 Tex6MatIdx
                                                     8 Tex7MatIdx
                                                     10:9 Position
                                                     12:11 Normal
                                                     14:13 ColorDiffused
                                                     16:15 ColorSpecular
    VCD_-H1       0ll0xxxx                           15:00 VCD 20 to 13
                                                     01:00 Tex0Coord
                                                     03:02 Tex1Coord
                                                     05:04 Tex2Coord
                                                     07:06 Tex3Coord
                                                     09:08 Tex4Coord
                                                     11:10 Tex5Coord
                                                     13:12 Tex6Coord
                                                     15:14 Tex7Coord
    VAT_group0    0111x,vat[2:0]                     32 bits
                                                     08:00 Position parameters
                                                     12:09 Normal parameters
                                                     16:13 ColorDiffused
     parameters
                                                     20:17 ColorSpecular
     parameters
                                                     29:21 Tex0Coord parameters
                                                     30:30 ByteDequant
                                                     31:31 NormalIndex3
    VAT_group1    1000x,vat[2:0]                     32 bits
                                                     08:00 Tex1Coord parameters
                                                     17:09 Tex2Coord parameters
                                                     26:18 Tex3Coord parameters
                                                     30:27 Tex4Coord parameters
     sub-field[3:0]
                                                     3l unused
    VAT_group2    100lx.vat[2:0]                     32 bits
                                                     04:00 Tex4Coord parameters
     sub-field[8:4]
                                                     13:05 Tex5Coord parameters
                                                     22:14 Tex6Coord parameters
                                                     31:23 Tex7Coord parameters
    ArrayBase     l0l0.array[3:0]                    32 bit data
                                                     25:00 Base(25:0)
                  array[3:0]:                        31:26 unused
                     0000 = attribute9  base register
                     0001 = attribute10 base register
                     0010 = attribute11 base register
                     0011 = attribute12 base register
                     0100 = attribute13 base register
                     0101 = attribute14 base register
                     0110 = attribute15 base register
                     0111 = attribute16 base register
                     1000 = attributel7 base register
                     1001 = attribute18 base register
                     1010 = artributel9 base register
                     1011 = attribute20 base register
                     1100 = IndexRegA base register
                     1101 = IndexRegB base register
                     1110 = IndexRegC base register
                     1111 = IndexRegD base register
    ArrayStride   1011,array[3:0]                    32 bit data
                                                     07:00 Stride(7:0)
                  array[3:00]:                       31:08 unused
                     0000 = attribute9 stride register
                     0001 = attribute10 stride register
                     0010 = attribute11 stride register
                     0011 = attribute12 stride register
                     0100 = attribute13 stride register
                     0101 = attribute14 stride register
                     0110 = attribute15 stride register
                     0111 = attribute16 stride register
                     1000 = attribute17 stride register
                     1001 = attributel8 stride register
                     1010 = attributel9 stride register
                     1011 = attribute20 stride register
                     1100 = IndexRegA stride register
                     1101 = IndexRegB stride register
                     1110 = IndexRegC stride register
                     1111 = IndexRegD stride register
</PRE><BR><BR>In the example embodiment, the command processor 200 converts the 
command stream to a vertex stream which it sends to transform unit 300 for 
further processing. The vertex stream sent to the transform unit 300 can change 
based on the current mode, but the data ordering per vertex is essentially the 
same and is fixed as shown in the following table: <BR><BR><PRE>    TABLE III
    Location in stream (in words) Data                       Description
    0 to 2                   X, Y, Z in 32b SPFP             Geometry
     information in single
                                                        precision floating
     point format
    3 to 5                   Nx, Ny, Nz in 32b SPFP     Normal vector
    6                        RGBA in 32b integer (8b/comp) Color0 per vertex
     (RGBA)
    7                        RGBA in 32b integer (8b/comp) Color1 per vertex
     (RGBA)
    8 to 10                  Tx, Ty, Tz in 32b SPFP     Binormal vector T
    11 to 13                 Bx, By, Bz in 32b SPFP     Binormal vector B
    14 to 15                 S0, T0 in 32b SPFP         Texture 0 data
    16 to 29                 Sn, Tn in 32b SPFP         Texture 1 to n data
</PRE><BR><BR>The location of words in the stream is order dependent, but not 
exact. For example, if the per-vertex color is not supplied, then the first 
texture will start at word 6 instead of word 8. Texture comes after color. 
<BR><BR>EXAMPLE GRAPHICS APPLICATION PROCESSING LOOP <BR><BR>FIG. 6 shows an 
example summary flow chart of steps that may be performed by system 50 under 
control of an application such as a video game program to develop graphics for 
display on the display 56. System 50 is first booted from boot ROM 134 (block 
610). During or after system boot, main processor 110 and graphics and audio 
processor 114 are initialized and the operating system is also initialized 
(block 612). System 50 is then ready to have its logic set up for a specific 
application, such as a videogame (block 614). The state of the graphics and 
audio processor 114 is set by sending an appropriate graphics command stream to 
the graphics and audio processor (block 616). The system 50 is then ready to 
process vertex information provided through a further command stream describing 
a primitive in terms of vertex data structure, and draw commands (block 618). 
Once the embedded frame buffer 702 has a completed frame of data, further 
commands sent to the graphics and audio processor 114 cause the processor to 
copy its embedded frame buffer to an external frame buffer 113 allocated in main 
memory 112 (block 620). The video interface 164 is then used to display the 
image data in the external frame buffer on a display device (block 622). Once a 
completed frame is copied from the embedded frame buffer, the system is ready to 
begin processing the next frame, as indicated by the frame loop 624 in FIG. 6. 
FIG. 7 shows is greater detail some of the possible graphics commands that can 
be performed in connection with each of the various steps shown in FIG. 6. 
<BR><BR>EXAMPLE SIMPLE GRAPHICS COMMAND STREAM <BR><BR>For purposes of 
illustration FIG. 8 shows an example simple graphics command stream drawing a 
single graphics primitive (e.g., a single triangle) on display 56. In this 
example simple graphics command stream, the first set of graphics commands 
initializes the graphics pipeline 180 (GXInit( )) (block 1002). When the 
graphics and audio processor 114 comes out of hardware reset, its internal 
register values are undefined and therefore need to be set by main processor 110 
under control of boot ROM 134 and/or the application program. A series of 
initialization commands such as register load commands may be issued to set the 
state of graphics and audio processor 114 to a known, pre-defined state that is 
suitable for the particular application that is to be performed. Of course, the 
application can reset any of these values to any other desired value on a 
dynamic basis. However, to save the application work, it may be desirable for 
boot ROM 134 to provide a series of state-setting graphics initialization 
commands that set up the graphics and audio processor 114 so that it is 
operating in a known functioning default graphics mode. <BR><BR>One example 
initialization may be to clear (set) the internal embedded frame buffer 702 to 
an all-black color value with z (distance) of the corresponding embedded depth 
buffer being set to infinite distance at each location. Such a "set copy clear" 
instruction effectively sets up a clean canvas onto which graphics and audio 
processor 114 can draw the next image, and is re-formed during an embedded frame 
buffer copy operation in the example embodiment. FIG. 9 shows an example binary 
data stream that may be sent to the graphics and audio processor 114 to control 
it to clear (set) its internal frame buffer 113 to a black color at each and 
every pixel location and to set the corresponding internal depth buffer to 
infinite distance at every pixel. In the particular example shown, such a 
command stream comprises three pixel engine register load commands: 
<BR><BR>pixel engine copy clear (alpha red), <BR><BR>pixel engine copy clear 
(green blue), <BR><BR>pixel engine copy clear (z). <BR><BR>In this example, the 
first portion of each register load command includes a "cp _cmd_su_bypass" 
command string (0x61) (where "0x" indicates hexadecimal). As explained in Table 
I above, this command string provides access to registers within graphics 
pipeline 180 below transform unit 300. This string is followed by a pixel engine 
register designation (1x4F in the case of a pixel engine copy clear alpha/red 
command), a 1-byte pad; and a 1-byte alpha value and a 1-byte red value (FF for 
black). <BR><BR>A similar format is used for the pe_copy_clear_green blue 
command except that the last two bytes indicate the green and blue values (FF 
for black), and a different pixel engine register designation (0x50) is used for 
the green/blue register values. Similarly, the pe_copy_clear_z command is issued 
by sending a cp_cmd_su_bypass string (0x61) followed by a register designator 
0x51 (designating a pixel engine z value register) followed by a 24-bit z 
(depth) value. The three set copy clear commands shown n FIG. 9 could be issued 
in any order (e.g., set z copy clear or set green/blue copy clear could be 
issued first). See FIG. 9A which shows example register formats. <BR><BR>In 
response to receipt of the FIG. 9 commands, pixel engine 700 writes the 
specified alpha, red, green, blue and z values into embedded frame buffer 702. 
<BR><BR>Referring once again to FIG. 8, a next step in preparing to display an 
image onto display 56 may be to define the various data structures associated 
with the vertices of the primitive to be drawn. The FIG. 10 diagram shows, for 
purposes of illustration, example vertex and vertex attribute descriptors that 
can be used to describe vertices. In the example embodiment, all vertices within 
a given primitive share the same vertex descriptor and vertex attribute format. 
The vertex descriptor in the example embodiment describes which attributes are 
present in a particular vertex format and how they are transmitted from the main 
processor 110 (or other source) to the graphics processor 114 (e.g., either 
direct or indexed). The vertex attribute format describes the format (e.g., 
type, size, format, fixed point scale, etc.) of each attribute in a particular 
vertex format. The vertex attribute format together with the vertex descriptor 
may be thought of as the overall vertex format. <BR><BR>The following is an 
example of a vertex attribute table (VAT) (see also above-referenced application 
Ser. No. 09/465,754 filed Dec. 17, 1999 entitled "Vertex Cache For 3D Computer 
Graphics") indexed by a draw command "vat" field, with each entry in the table 
specifying characteristics for all of the thirteen attributes: <BR><BR><PRE>                                       TABLE IV
                             VERTEX ATTRIBUTE TABLE (VAT)
    Attribute Attribute
    number    name        bits  Encoding
    0         PosMatIdx   0     Position/normal matrix index. Always direct if
     present
                                0: not present 1: present
                                NOTE: position and normal matrices are stored
     in 2 separate
                                RAMs in the Xform unit, but there is a one to
     one correspondence
                                between normal and position index. If index "A"
     is used for the
                                position. then index "A" needs to be used for
     the normal as well.
    1         Tex0MatIdx  1     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    2         Tex1MatIdx  2     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    3         Tex2MatIdx  3     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    4         Tex3MatIdx  4     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    5         Tex4MatIdx  5     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    6         Tex5MatIdx  6     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    7         Tex6MatIdx  7     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    8         Tex7MatIdx  8     TextCoord0 matrix index, always direct if
     present
                                0: not present 1: present
    9         Position    10:9  00: reserved 10:8 bit index
                                01: direct 11:l6 bit index
    10        Normal      12:11 00: not present 10:8 bit index
                                01: direct 11:l6 bit index
    11        Color0      14:13 00: not present 10:8 bit index
                                01: direct 11:16 bit index
    12        Color1      16:15 00: not present 10:8 bit index
                                01: direct 11:l6 bit index
    13        Tex0Coord   18:17 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
    14        Tex1Coord   20:19 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
    15        Tex2Coord   22:21 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
    16        Tex3Coord   24:23 00: not present
                                01: direct
                                10:8 bit index
                                11:l6 bit index
    17        Tex4Coord   26:25 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
    18        Tex5Coord   28:27 Same as above
    19        Tex6Coord   30:29 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
    20        Tex7Coord   32:31 00: not present
                                01: direct
                                10:8 bit index
                                11:16 bit index
</PRE><BR><BR>As described in application Ser. No. 09/465,754, as well as above, 
entries in the vertex descriptor information can be either direct or indexed. 
Indexed vertex attributes include an index to an array instead of a value. The 
index may be an 8-bit or 16-bit pointer into an array of attributes. In the 
example embodiment, there is one base address register per attribute in the 
command processor 200. The index is not simply an offset into the array, but 
rather depends on a number of factors including, for example, the number of 
components in the attribute; the size of the component; padding between 
attributes for alignment purposes; and whether multiple attributes are 
interleaved in the same array. To provide maximum flexibility, there is also an 
array stride register for each attribute. The distance between two attributes 
(computed by software) is loaded into this register. Calculations are used to 
calculate the offset and to calculate the actual memory address based on an 
index value. An example address calculation is as follows: <BR><BR>Memory 
address=ArrayBase[I]+index*ArrayStride[I], <BR><BR>where I is the attribute 
number. In one particular implementation, the ArrayBase value is a 26-bit byte 
address, and ArrayStride is an 8-bit value. <BR><BR>A vertex can have direct and 
indirect attributes intermixed. For short values, it may be more efficient to 
send the actual value than a pointer to the value. Any attribute in the example 
embodiment can be sent directly or as in index into an array. <BR><BR>In 
general, the steps required to draw a primitive include describing which 
attributes are present in the vertex format (i.e., define the vertex attribute 
table); describing whether the attributes are indexed or referenced directly 
(i.e., define the vertex descriptor); for indexed data, delivering a vertex 
array that can be referenced by array pointers and strides; describing the 
number of elements in each attribute and their type; describing the primitive 
type; and then, finally, drawing the primitive by sending the graphics processor 
114 draw command with a stream of vertices that match the vertex description in 
attribute format (see FIG. 8, blocks 1004, 1006, 1008). <BR><BR>FIG. 11 shows an 
example "set array" command used to help define a vertex format (see FIG. 8 
block 1004, "Define and Align Vertex Arrays"). In the example embodiment, the 
example "set array" command sets the command processor array base register for a 
particular vertex array and also sets the array stride register for the array. 
FIG. 11 shows particular example binary bit patterns that may be used for this 
command. In this example, to set an array base register, the graphics command 
stream may include: <BR><BR>an initial "0x08" value indicating "cp_cmd_load reg" 
(i.e., load a command processor 200 register) followed by <BR><BR>a 2-byte value 
indicating which array base register is to be loaded, followed by <BR><BR>an 
additional 4-byte value providing an address to the array in memory. <BR><BR>In 
this particular example, the 2-byte value indicating which array base register 
is to be loaded has the format "1xAx", where the byte "x" following the "A" 
value encodes a particular one of the attributes set forth in Table IV above. 
Note that some of the Table IV attributes (i.e., the matrix indices) are not 
included in the encoding in the example embodiment. In the example embodiment, 
the 4-byte address in memory is encoded by providing six initial bits of 0 
padding followed by a 26-bit address. Setting the array stride register value is 
similar except that the third and fourth bytes indicate an array stride register 
(e.g., "1xBx" and the following value comprises four bytes containing an initial 
24-bit 0 padded value and an 8-bit stride value for the array. <BR><BR>Referring 
once again to FIG. 8, a further step preliminary to issuing a draw command may 
be to set up a vertex descriptor and a vertex attribute table (block 1006). FIG. 
12 shows an example command stream used to set a vertex descriptor. In the 
example embodiment, setting a vertex descriptor involves setting two associated 
register values ("vcd_lo" "vcd_hi") within command processor 200 in order to 
specify the particular vertex descriptor attributes associated with the 
primitive to be displayed. FIG. 12 shows particular binary encodings used to 
tell the graphics and audio processor 114 to load the vcd_lo and vcd_hi 
registers (e.g., "0x0850" for an example vcd_lo register and "0x0860" to specify 
loading a cp_vcd_hi register). Values following each of these 4-byte commands 
indicates particular vertex attribute values as shown in Table 4 above, and as 
encoded in the particular binary bit patterns slots shown in FIG. 12. <BR><BR>In 
more detail, the vertex descriptor stored in the VCD_lo VCD_hi register includes 
at least one bit for each of the twenty attributes shown in Table IV, that bit 
generally indicating whether the attribute is provided directly or via an array. 
In the example embodiment, the VCD_lo register contains a 17-bit value, 
providing bit flags indicating direct or indexed for each of the first twelve 
attributes in Table IV. The particular bit encodings are shown in the last 
column of Table IV. Note that certain attribute encodings indicate whether or 
not the attribute is present (since the attribute is always direct if it is 
present), and certain other encodings span multiple bits and provide information 
as to the type of index if the attribute is indexed (e.g., the "position" value 
may span two bits with a value "01" for direct. "10" for 8-bit index, and "11" 
for 16-bit index). Similarly, the VCD_hi register contains bit fields 
corresponding to attributes 13-20 (i.e., texture 0 coordinate through texture 7 
coordinate) as shown in Table IV above. <BR><BR>On a more abstract level, the 
GXSetVtxDesc command is used to indicate whether an attribute is present in the 
vertex data, and whether it is indexed or direct. There is only one active 
vertex descriptor, known as the current vertex descriptor. A GXSetVtxDesc 
command can be used to set a value of GX_NONE for all the attributes in the 
current vertex descriptor to indicate that no data for this attribute will be 
present in the vertex. Once the VCD registers are cleared, the application only 
needs to describe attributes that it intends to provide. As shown in Table IV, 
possible attributes are: <BR><BR>Position, GX_VA_POS (this attribute is required 
for every vertex descriptor). <BR><BR>Normal, GX_VA_NRM, or 
normal/binormal/tangent, GX_VA_NBT. <BR><BR>Color.sub.-- 0, GX_VA_CLR0. 
<BR><BR>Color.sub.-- 1, GX_VA_CLR1. <BR><BR>Up to 8 texture coordinates, 
GX_VA_TEX0-7. <BR><BR>A position/normal matrix index, GX_VA_PNMTXIDX. <BR><BR>A 
texture matrix index, GX_VA_TEXOMTXIDX-GX_VA_TEX7MTXIDX. <BR><BR>The last two 
attributes listed are 8-bit indices which are used for referencing a 
transformation matrix in the on-chip matrix memory. This supports simple 
skinning of a character, for example. These indices are different from the other 
attributes in that they may only be sent as direct data. <BR><BR>The graphics 
processor (GP) 114 assumes that the application will send any attribute data you 
have specified in the ascending order shown in Table IV, that is: <BR><BR>Order 
Attribute <BR><BR>0 GX_VA_PNMTXIDX <BR><BR>1 GX_VA_TEXOMTXIDX <BR><BR>2 
GX_VA_TEX1MTXIDX <BR><BR>3 GX_VA_TEX2MTXIDX <BR><BR>4 GX_VA_TEX3MTXIDX <BR><BR>5 
GX_VA_TEX4MTXIDX <BR><BR>6 GX_VA_TEX5MTXIDX <BR><BR>7 GX_VA_TEX6MTXIDX <BR><BR>8 
GX_VA_TEX7MTXIDX <BR><BR>9 GX_VA_POS <BR><BR>10 GX_VA NRMorGX_VA_NBT <BR><BR>11 
GX_VA_CLR1 <BR><BR>12 GX_VA_CLR1 <BR><BR>13 GX_VA_TEX1 <BR><BR>14 GX_VA_TEX1 
<BR><BR>15 GX_VA_TEX2 <BR><BR>16 GX_VA_TEX3 <BR><BR>17 GX_VA_TEX4 <BR><BR>18 
GX_VA_TEX5 <BR><BR>19 GX_VA_TEX6 <BR><BR>20 GX_VA_TEX7 <BR><BR>Texture 
coordinates are enabled sequentially, starting at GX_VA_TEX0. <BR><BR>DESCRIBING 
ATTRIBUTE DATA FORMATS <BR><BR>FIGS. 13A and 13B show an example command stream 
for setting vertex attribute formats. The Vertex Attribute Format Table (VAT) 
allows the application to specify the format of each attribute for up to eight 
different vertex formats. The VAT is organized as shown in FIG. 14. The 
application can store eight predefined vertex formats in the table. For each 
attribute in a vertex, the applicaiton can specify the following: <BR><BR>The 
number of elements for the attribute. <BR><BR>The format and size information. 
<BR><BR>The number of fractional bits for fixed-point formats using the scale 
parameter (the scale parameter is not relevant to color or floating-point data). 
<BR><BR>EXAMPLE VERTEX ATTRIBUTE FORMAT COMMAND (GXSETVTXATTRFMT) 
<BR><BR>//format index attribute n elements format n frac bits 
<BR><BR>GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0); 
<BR><BR>GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLRO, GX_CLR_RGBA, GX_RGBA8, 0); 
<BR><BR>The high-level code above defines vertex attribute format zero. 
GX_VTXFMT0 indicates that "position" is a 3-element coordinate (x, y, z) where 
each element is an 8-bit 2's complement signed number. The scale value indicates 
the number of fractional bits for a fixed-point number, so zero indicates that 
the data has no fractional bits. The second command specifies that the 
GX_VA_CLR0 attribute has four elements (r, g, b, a) where each element is 8 
bits. The matrix index format is not specified in the table because it is always 
an unsigned 8-bit value. The scale value is implied for normals (scale=6 or 
scale=14) and not needed for colors. Also, normals are assumed to have three 
elements, Nx, Ny, Nz (for GX_VA_NRM), and nine elements, Nx, Ny, Nz, Bx, By, Bz, 
Tx, Ty, Tz (for GX_VA_NBT). Normals are generally always signed values. The 
normal format (GX_VA_NRM) is also used for binormals/tangents (GX_VA_NBT) when 
they are enabled in the current vertex descriptor. The VAT in the Graphics 
Processor has room for eight vertex formats. The application can describe most 
of its attribute quantization formats early in the application, loading this 
table as required. Then the application provides an index into this table, which 
specifies the vertex attribute data format, when it starts drawing a group of 
primitives. If the application requires more than eight vertex formats it must 
manage the VAT table by reloading new vertex formats as needed. <BR><BR>FIGS. 
13A and 13B show example binary-level commands for controlling the graphics and 
audio processor 114 to load an example vertex attribute table (VAT). In the 
example embodiment, the VAT spins three separate register loads (VAT_A, VAT_B, 
VAT_C) so that setting a vertex attribute format involves writing values to 
three internal "VAT" registers within the graphics and audio processor 114, 
i.e.: <BR><BR>"0x0870" [4-byte value] to write to the cp_VAT_A register, 
<BR><BR>"0x0880" [4-byte value] to write to the cp_VAT_B register, and 
<BR><BR>"0x0890" [4-byte value] to write to the cp_VAT_C register. <BR><BR>As 
shown in FIG. 13A, the binary bit field encoding for the VAT_A register write 
involves providing position, normal, color 1, color 2, texture 0 coordinate, and 
other information (i.e., byte dequantization and normal index bits) in the 
binary pattern slots shown. Similarly, the binary bit field encoding for the 
VAT_B register write invovlves providing formatting information for texture 
coordinate 1, texture coordinate 2, texture coordinate 3 and part of texture 
coordinate 4; and the information to be stored in the VAT_C register provides 
attribute format information for the rest of texture coordinate 4, texture 
coordinate 5, texture coordinate 6 and texture coordinate 7. FIGS. 13A and 13B 
show the particular bit pattern encodings that may be used. Additional 
explanation of these particular attributes is set forth in Table V: <BR><BR><PRE>    TABLE V
    Bit   Attribute Attribute     .CompCount    .CompSize              Shift
     amount
    field number    name          sub-field(0)  sub-field(3:1)
     sub-field(8:4)
    8:0   9         Position      0: two (x,y)  0:ubyte 1:byte 2:ushort
     Location of decimal point
                                  1:three       3:short 4:float 5-7    from
     LSB. This shift applies
                                  (x,y,z)       reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    12:9  10        Normal        0: three      0:reserved 1:byte      NA
     (Byte: 6, Short: 14)
                                  normals       2:reserved
                                  1: nine       3:short 4:float 5-7
                                  normals       reserved
    16:13 11        Color0        0: three      0:16 bit 565 (three comp) NA
                                  (r,g,b)       1:24 bit 888 (three comp)
                                                2:32 bit 888x (three
                                                comp)
                                  1: four       3:16 bit 4444 (four comp)
                                  (r,g,b,a)     4:24 bit 6666 (four comp)
                                                5:32 bit 8888 (four comp)
    20:17 12        Color1        0: three      0:16 bit 565 (three comp) NA
                                  (r,g,b)       1:24 bit 888 (three comp)
                                                2:32 bit 888x (three comp)
                                                3:16 bit 4444 (four comp)
                                  1: four       4:24 bit 6666 (four comp)
                                  (r,g,b,a)     5:32 bit 8888 (four comp)
    29:21 13        Tex0Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    38:30 14        Tex1Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    47:39 15        Tex2Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    56:48 16        Tex3Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    65:57 17        Tex4Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    74:66 18        Tex5Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    83:75 19        Tex6Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s,t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    92:84 20        Tex7Coord     0: one (s)    0:ubyte 2:ushort 4:float
     Location of decimal point
                                  1: two (s.t)  1:byte 3:short 5-7     from
     LSB. This shift applies
                                                reserved               to all
     u/short components and
                                                                       to
     u/byte components where
     ByteDequant is asserted
                                                                       (Below).
    93:93 FLAG      ByteDequant   (Rev B Only)  0: Shift does not apply to
     Shift applies for u/byte
                                                u/byte
     components of position and
                                                1: Shift does apply to texture
     attributes.
                                                u/byte
    94:94 FLAG      NormalIndex3  (Rev B Only)  0: Single index per Normal When
     nine normals selected
                                                1: Triple index per nine- in
     indirect mode, input will
                                                Normal                 be
     treated as three staggered
                                                                       indices
     (one per triple biased
                                                                       by
     component size), into
                                                                       normal
     table.
                                                                       NOTE!!
                                                                       First
     index internally biased
                                                                       by 0.
                                                                       Second
     index internally
                                                                       biased
     by 1.
                                                                       Third
     index internally
                                                                       biassed
     by 2.
</PRE><BR><BR>DEFINING AND DRAWING GRAPHICS PRIMITIVES <BR><BR>FIG. 15 
illustrates some of the different types of primitives supported by the graphics 
system 50, including: <BR><BR>GX_POINTS--draws a point at each of the n 
vertices. <BR><BR>GX_LINES--draws a series of unconnected line segments. 
Segments are drawn between v0 and v1, v2 and v3, etc. The number of vertices 
drawn should be a multiple of 2. <BR><BR>GX_LINESTRIP--draws a series of 
connected lines, from v0 to v1, then from v1 to v2, and so on. If n vertices are 
drawn, n-1 lines are drawn. <BR><BR>GX_TRIANGLES--draws a series of triangles 
(three-sided polygons) using vertices v0, v1, v2, then v3, v4, v5, and so on. 
The number of vertices drawn should be a multiple of 3 and the minimum number is 
3. <BR><BR>GX_TRIANGLSTRIP--draws a series of triangles (three-sided polygons) 
using vertices v0, v1, v2, then v1, v3, v2 (note the order), then v2, v3, v4, 
and so on. The number of vertices must be at least 3. 
<BR><BR>GX_TRIANGLEFAN--draws a series of triangles (three-sided polygons) using 
vertices v0, v1, v2, then v0, v2, v3, and so on. The number of vertices must be 
at least 3. <BR><BR>GX_QUADS--draws a series of non-planar quadrilaterals 
(4-sided polygons) beginning with v0, v1, v2, v3, then v4, v5, v6, v7, and so 
on. The quad is actually drawn using two triangles, so the four vertices are not 
required to be coplanar. it is noted that the diagonal common edge between the 
two triangles of a quad is oriented as shown in FIG. 11. The minimum number of 
vertices is 4. <BR><BR>The application draws primitives by calling vertex 
functions (GXPosition, GXColor, etc.) between GXBegin/GXEnd pairs. The 
application should call a vertex function for each attribute it enables using 
GXSetVtxDesc( ). Each vertex function has a suffix of the form GXData[n][t], 
which describes the number (n) and type (t) of elements passed to the vertex 
function. <BR><BR>The following case fragment demonstrates how to draw 
primitives using vertex functions: <BR><BR>GXBegin(GX_TRIANGLES, GX_VTXFMTO, 3); 
<BR><BR>GXPosition1x8(0); // index to position <BR><BR>GXColor1x16(0); // index 
to color <BR><BR>GXPosition1x8(1); <BR><BR>GXColor1x16(1); 
<BR><BR>GXPosition1x8(2); <BR><BR>GXColor1x16(2); <BR><BR>GXEnd( ); 
<BR><BR>GXBegin specifies the type of primitive, an index into the VAT, and the 
number of vertices between the GXBegin/GXEnd pair. This information, along with 
the latest call to GXSetVtxDesc( ), fully describes the primitive, vertex, and 
attribute format. GXEnd( ) is actually a null macro that can be used to make 
sure that GXBegin and GXEnd are paired properly. <BR><BR>LOADING A PROJECTION 
MATRIX <BR><BR>FIG. 16 shows an example binary bit stream used to load a 
projection matrix into transform unit 300 (see FIG. 8, block 1004). As described 
above in connection with FIG. 8, the application generally defines a projection 
matrix in order to transform a primitive from one space into another space 
(e.g., object space to world space). The transform unit 300 automatically 
transforms the vertices in the primitive using this projection matrix. 
<BR><BR>FIG. 16 shows an example binary bit stream that can be used to load a 
projection matrix into transform unit 300. In the example embodiment, this 
loading process involves sending a binary bit pattern of "0x10" to the graphics 
and audio processor 114 indicating "cp.sub.13 cmd.sub.13 xf.sub.13 loadregs" 
followed by a 4-byte value. In this 4-byte value, the first eleven bits are 0 
padding and the succeeding bits indicated a register address within the 
transform unit 300 (bits 0-15) and the number of 32-bit registers within the 
transform unit to be loaded (bits 16-19). Following these bit patterns are a 
sequence of from one to sixteen 32-bit words specifying projection matrix 
values. <BR><BR>In the example embodiment, every register in the transform unit 
300 is mapped to a unique 32b address. All addresses are available to the xform 
register load command (command 0x30). The first block is formed by the matrix 
memory. Its address range is 0 to 1k, but only 256 entries are used. This memory 
is organized in a 64 entry by four 32b words. Each word has a unique address and 
is a single precision floating point number. For block writes, the addresses 
auto increment. The memory is implemented in less than 4-32b rams, then it is 
possible that the memory writes to this block will require a minimum write size 
larger than 1 word: <PRE>        Register Address  Definition           Configuration
        0x0000            Matrix Ram word 0    32b matrix data
        0x0001-0x00ff     Matrix Ram word (n)  32b matrix data
        0x0100-0x03ff     Not used
</PRE><BR><BR>The second block of memory is mapped to the 1 k.about.1.5 k range. 
This memory is the normal matrix memory. It is organized as 32 rows of 3 words. 
Each word has a unique address and is a single precision floating point number. 
Also, each word written is 32b, but only the 20 most significant bits are kept. 
For simplicity, the minimum granularity of writes will be 3 words: <PRE>        Register Address  Definition             Configuration
        0x0400-0x402      Normal Ram words 0,1,2 20b data
        0x0403-0x045f     Normal Ram word (n)    20b data
        0x0460-0x05ff     Not used
</PRE><BR><BR>The third block of memory holds the dual texture transform 
matrices. The format is identical to the first block of matrix memory. There are 
also 64 rows of 4 words for these matrices. These matrices can only be used for 
the dual transform of regular textures: <PRE>        Register Address  Definition           Configuration
        0x0500            Matrix Ram word 0    32b matrix data
        0x0501-0x05ff     Matrix Ram word (n)  32b matrix data
</PRE><BR><BR>The fourth block of memory is the light memory. This holds all the 
lighting information (light vectors, light parameters, etc.). Both global state 
and ambient state are stored in this memory. Each word written is 32b, but only 
the 20 most significant bits are kept. Each row is 3 words wide. Minimum word 
write size is 3 words. <BR><BR>EXAMPLE CALL DISPLAY LIST COMMAND <BR><BR>As 
described in the above-referenced patent application Ser. No. 09/726,215, filed 
Nov. 28, 2000 (atty. dkt. no. 723-959) entitled "Method and Apparatus for 
Buffering Graphics Data in a Graphics System", system 50 includes a capability 
for calling a display list. FIG. 17 shows an example binary bit stream format 
used to call a display object such as a display list. In the example shown, the 
binary bit pattern format inlcudes an initial "0x40"indicating "CP.sub.13 
CMD.sub.13 CALLOBJECT", followed by a 4-byte address of the display list in 
memory as well as a 4-byte count or size of the display list. The 4-byte address 
field may include an initial seven bits of 0 padding followed by a 25-bit value. 
The 4-byte count value may include an initial seven bits of padding followed by 
a 25-bit count value indicating the count or size of the display list in 32-byte 
chunks. <BR><BR>OTHER EXAMPLE COMPATIBLE IMPLEMENTATIONS <BR><BR>Certain of the 
above-described system components 50 could be implemented as other than the home 
video game console configuration described above. For example, one could run 
graphics application or other software written for system 50 on a platform with 
a different configuration that emulates system 50 or is otherwise compatible 
with it. If the other platform can successfully emulate, simulate and/or provide 
some or all of the hardware and software resources of system 50, then the other 
platform will be able to successfully execute the software. <BR><BR>As one 
example, an emulator may provide a hardware and/or software configuration 
(platform) that is different from the hardware and/or software configuration 
(platform) of system 50. The emulator system might include software and/or 
hardware components that emulate or simulate some or all of hardware and/or 
software components of the system for which the application software was 
written. For example, the emulator system could comprise a general purpose 
digital computer such as a personal computer, which executes a software emulator 
program that simulates the hardware and/or firmware of system 50. <BR><BR>Some 
general purpose digital computers (e.g., IBM or MacIntosh personal computers and 
compatibles) are now equipped with 3D graphics cards that provide 3D graphics 
pipelines compliant with DirectX or other standard 3D graphics command APIs. 
They may also be equipped with stereophonic sound cards that provide high 
quality stereophonic sound based on a standard set of sound commands. Such 
multimedia-hardware-equipped personal computers running emulator software may 
have sufficient performance to approximate the graphics and sound performance of 
system 50. Emulator software controls the hardware resources on the personal 
computer platform to simulate the processing, 3D graphics, sound, peripheral and 
other capabilities of the home video game console platform for which the game 
programmer wrote the game software. <BR><BR>FIG. 18A illustrates an example 
overall emulation process using a host platform 1201, an emulator component 
1303, and a game software executable binary image provided on a storage medium 
62. Host 1201 may be a general or special purpose digital computing device such 
as, for example, a personal computer, a video game console, or any other 
platform with sufficient computing power. Emulator 1303 may be software and/or 
hardware that runs on host platform 1201, and provides a real-time conversion of 
commands, data and other information from storage medium 62 into a form that can 
be processed by host 1201. For example, emulator 1303 fetches "source" 
binary-image program instructions intended for execution by system 50 from 
storage medium 62 and converts these program instructions to a target format 
that can be executed or otherwise processed by host 1201. <BR><BR>As one 
example, in the case where the software is written for execution on a platform 
using an IBM <B><I>PowerPC</I></B> or other specific processor and the host 1201 
is a personal computer using a different (e.g., Intel) processor, emulator 1203 
fetches one or a sequence of binary-image program instructions from storage 
medium 1305 and converts these program instructions to one or more equivalent 
Intel binary-image program instructions. The emulator 1203 also fetches and/or 
generates graphics commands and audio commands intended for processing by the 
graphics and audio processor 114, and converts these commands into a format or 
formats that can be processed by hardware and/or software graphics and audio 
processing resources available on host 1201. As one example, emulator 1303 may 
convert these commands into commands that can be processed by specific graphics 
and/or or sound hardware of the host 1201 (e.g., using standard DirectX, OpenGL 
and/or sound APIs). <BR><BR>An emulator 1303 used to provide some or all of the 
features of the video game system described above may also be provided with a 
graphic user interface (GUI) that simplifies or automates the selection of 
various options and screen modes for games run using the emulator. In one 
example, such an emulator 1303 may further include enhanced functionality as 
compared with the host platform for which the software was originally intended. 
<BR><BR>FIG. 18B illustrates an emulation host system 1201 suitable for use with 
emulator 1303. System 1201 includes a processing unit 1203 and a system memory 
1205. A system bus 1207 couples various system components including system 
memory 1205 to processing unit 1203. System bus 1207 may be any of several types 
of bus structures including a memory bus or memory controller, a peripheral bus, 
and a local bus using any of a variety of bus architectures. System memory 1207 
includes read only memory (ROM) 1252 and random access memory (RAM) 1254. A 
basic input/output system (BIOS) 1256, containing the basic routines that help 
to transfer information between elements within personal computer system 1201, 
such as during start-up, is stored in the ROM 1252. System 1201 further includes 
various drives and associated computer-readable media. A hard disk drive 1209 
reads from and writes to a (typically fixed) magnetic hard disk 1211. An 
additional (possible optional) magnetic disk drive 1213 reads from and writes to 
a removable "floppy" or other magnetic disk 1215. An optical disk drive 1217 
reads from and, in some configurations, writes to a removable optical disk 1219 
such as a CD ROM or other optical media. Hard disk drive 1209 and optical disk 
drive 1217 are connected to system bus 1207 by a hard disk drive interface 1221 
and an optical drive interface 1225, respectively. The drives and their 
associated computer-readable media provide nonvolatile storage of 
computer-readable instructions, data structures, program modules, game programs 
and other data for personal computer system 1201. In other configurations, other 
types of computer-readable media that can store data that is accessible by a 
computer (e.g., magnetic cassettes, flash memory cards, digital video disks, 
Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs) 
and the like) may also be used. <BR><BR>A number of program modules including 
emulator 1303 may be stored on the hard disk 1211, removable magnetic disk 1215, 
optical disk 1219 and/or the ROM 1252 and/or the RAM 1254 of system memory 1205. 
Such program modules may include an operating system providing graphics and 
sound APIs, one or more application programs, other program modules, program 
data and game data. A user may enter commands and information into personal 
computer system 1201 through input devices such as a keyboard 1227, pointing 
device 1229, microphones, joysticks, game controllers, satellite dishes, 
scanners, or the like. These and other input devices can be connected to 
processing unit 1203 through a serial port interface 1231 that is coupled to 
system bus 1207, but may be connected by other interfaces, such as a parallel 
port, game port Fire wire bus or a universal serial bus (USB). A monitor 1233 or 
other type of display device is also connected to system bus 1207 via an 
interface, such as a video adapter 1235. <BR><BR>System 1201 may also include a 
modem 1154 or other network interface means for establishing communications over 
a network 1152 such as the Internet. Modem 1154, which may be internal or 
external, is connected to system bus 123 via serial port interface 1231. A 
network interface 1156 may also be provided for allowing system 1201 to 
communicate with a remote computing device 1150 (e.g., another system 1201) via 
a local area network 1158 (or such communication may be via wide area network 
1152 or other communications path such as dial-up or other communications 
means). System 1201 will typically include other peripheral output devices, such 
as printers and other standard peripheral devices. <BR><BR>In one example, video 
adapter 1235 may include a 3D graphics pipeline chip set providing fast 3D 
graphics rendering in response to 3D graphics commands issued based on a 
standard 3D graphics application programmer interface such as Microsoft's 
DirectX 7.0 or other version. A set of stereo loudspeakers 1237 is also 
connected to system bus 1207 via a sound generating interface such as a 
conventional "sound card" providing hardware and embedded software support for 
generating high quality stereophonic sound based on sound commands provided by 
bus 1207. These hardware capabilities allow system 1201 to provide sufficient 
graphics and sound speed performance to play software stored in storage medium 
1305. <BR><BR>EXAMPLE HIGHER-LEVEL API CELLS <BR><BR>The following show example 
higher level API cells that a library interprets and/or computes to create the 
binary level command streams described above: <BR><BR>GXSetCopyClear 
<BR><BR>Argument: <PRE>    GXColor     ClearColor;   //Color value to clear the framebuffer
                              to during copy.
    u32         ClearZ;       //24 bit Z value to clear the framebuffer
                              to during copy.
</PRE><BR><BR>This sets the two clear values used for clearing the framebuffer 
during copy operations. <BR><BR>GXSetVtxDesc <BR><BR>Arguments: <PRE>    GXAttr      Attr;    //Which attribute (Position, Normal, Color, etc.)
    GXAttrType  Type;   //Attribute Type (None, Direct, Indexed, etc.)
</PRE><BR><BR>This function is used for setting the type of a single attribute 
in the current vertex descriptor (i.e., vertex attribute register). The vertex 
attribute register defines which attributes are present in a vertex and how each 
attribute is referenced. <BR><BR>GXSetVtxAttrFmt <BR><BR>Argument: <PRE>    GXVtxFmt      vtxfint;    //Index into the Vertex Attribute Table
                              (0-7).
    GXAttr        Attr;       //Attribute Type.
    GXCompCnt     CompCnt;    //Number of components for the attribute.
    GXCompType    CompType    //Type of each Component.
    u8            Shift;      //Locatin of decimal point for fixed point
                              format types.
</PRE><BR><BR>This function sets the attribute format for a single attribute in 
the vertex attribute format table (VAT). There are 8 vertex formats in the VAT 
vertex attribute array. Each register describes the data type and component 
types of all attributes that can be used in a vertex packet. The application can 
preprogram all 8 registers and then select one of them during actual drawing of 
the geometry. <BR><BR>GXSetArray <BR><BR>Arguments: <PRE>    GXAttr  Attr;   //Attribute type.
    u32     Base;   //Address (25:0) of the attribute data array in main
                    memory.
    u8      Stride; //Number of bytes between successive elements in the
                    attribute array.
</PRE><BR><BR>This function sets the address and stride of the data array in 
main memory for each indexed attribute. The system uses these arrays to get 
actual data when an indexed attribute is sent with a vertex packet. 
<BR><BR>GXSetProjection <BR><BR>Arguments: <PRE>        f32               Matrix[4] [4] //Projection matrix.
        GXProjMtxType     type;         //Indicates if the projection is
                                        orthographic.
</PRE><BR><BR>Sets projection matrix parameters. The projection matrix is 
specified as follows: <BR><BR>Perspective Projection: ##EQU1## 
<BR><BR>Orthographic Projection: ##EQU2## <BR><BR>All documents referred to 
herein are expressly incorporated by reference as if expressly set forth. 
<BR><BR>As used herein, the notation "0x" indicates a hexadecimal value. For 
example, "0x61" indicates a hexadecimal value. For example, "0x61" indicates a 
two-byte hexadecimal value of "61" --which people of ordinary skill in the art 
understand has a binary format of "01100001". See Table VI below for conversion 
of hexadecimal notation to binary notation: <BR><BR><PRE>                    TABLE VI
                     Hex                 Binary
                      0                   0000
                      1                   0001
                      2                   0010
                      3                   0011
                      4                   0100
                      5                   0101
                      6                   0110
                      7                   0111
                      8                   1000
                      9                   1001
                      A                   1010
                      B                   1011
                      C                   1100
                      D                   1101
                      E                   1110
                      F                   1111
</PRE><BR><BR>While the invention has been described in connection with what is 
presently considered to be the most practical and preferred embodiment, it is to 
be understood that the invention is not to be limited to the disclosed 
embodiment, but on the contrary, is intended to cover various modifications and 
equivalent arrangements included within the scope of the appended claims. 
<BR><BR>
<CENTER><B>* * * * *</B></CENTER>
<HR>

<CENTER><!-- <A HREF="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=/netahtml/search-adv.htm&r=18&f=G&l=50&d=PTXT&p=1&S1=(Nintendo+AND+PowerPC)&OS=Nintendo+AND+PowerPC"><img border=0 src="/netaicon/PTO/patbib.gif" valign=middle></A> --><A 
href="http://patimg2.uspto.gov/.piw?Docid=06489963&amp;homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%2Fnetahtml%2Fsearch-adv.htm%2526r%3D19%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526p%3D1%2526S1%3D(Nintendo%252BAND%252BPowerPC)%2526OS%3DNintendo%252BAND%252BPowerPC%2526RS%3D&amp;PageNum=&amp;Rtype=&amp;SectionNum=&amp;idkey=78709CC1D7AA"><IMG 
alt=[Image] src="6,489,963 - GX API.files/image.gif" border=0 
valign="middle"></A> 
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle><A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%2Fnetahtml%2Fsearch-adv.htm%26r%3D19%26f%3DG%26l%3D50%26d%3DPTXT%26p%3D1%26S1%3D(Nintendo%252BAND%252BPowerPC)%26OS%3DNintendo%252BAND%252BPowerPC&amp;backLabel1=Back%20to%20Document%3A%206,489,963"><IMG 
      alt="[View Shopping Cart]" src="6,489,963 - GX API.files/cart.gif" 
      border=0 valign="middle"></A> <A 
      href="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=6,489,963&amp;backUrl1=http%3A//164.195.100.11/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%2Fnetahtml%2Fsearch-adv.htm%26r%3D19%26f%3DG%26l%3D50%26d%3DPTXT%26p%3D1%26S1%3D(Nintendo%252BAND%252BPowerPC)%26OS%3DNintendo%252BAND%252BPowerPC&amp;backLabel1=Back%20to%20Document%3A%206,489,963"><IMG 
      alt="[Add to Shopping Cart]" src="6,489,963 - GX API.files/order.gif" 
      border=0 valign="middle"></A> </TD></TR>
  <TR>
    <TD align=middle><A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=19&amp;f=S&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;Query=Nintendo+AND+PowerPC"><IMG 
      alt=[HIT_LIST] src="6,489,963 - GX API.files/hitlist.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=18&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC"><IMG 
      alt=[PREV_DOC] src="6,489,963 - GX API.files/prevdoc.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=20&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC"><IMG 
      alt=[NEXT_DOC] src="6,489,963 - GX API.files/nextdoc.gif" border=0 
      VALIGN="MIDDLE"></A> <A 
      href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&amp;Sect2=HITOFF&amp;u=/netahtml/search-adv.htm&amp;r=19&amp;f=G&amp;l=50&amp;d=PTXT&amp;p=1&amp;S1=(Nintendo+AND+PowerPC)&amp;OS=Nintendo+AND+PowerPC#top"><IMG 
      alt=[Top] src="6,489,963 - GX API.files/top.gif" border=0 
      valign="middle"></A> </TD></TR></TBODY></TABLE><A name=bottom></A><A 
href="http://www.uspto.gov/patft/index.html"><IMG alt=[Home] 
src="6,489,963 - GX API.files/home.gif" border=0 valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-bool.html"><IMG 
alt="[Boolean Search]" src="6,489,963 - GX API.files/boolean.gif" border=0 
valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/search-adv.htm"><IMG alt="[Manual Search]" 
src="6,489,963 - GX API.files/manual.gif" border=0 valign="middle"></A> <A 
href="http://patft.uspto.gov/netahtml/srchnum.htm"><IMG alt="[Number Search]" 
src="6,489,963 - GX API.files/number.gif" border=0 valign="middle"></A> <A 
href="http://www.uspto.gov/patft/help/help.htm"><IMG alt=[Help] 
src="6,489,963 - GX API.files/help.gif" border=0 valign="middle"></A> 
</CENTER></BODY></HTML>
